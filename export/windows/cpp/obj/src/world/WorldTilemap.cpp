// Generated by Haxe 3.4.0
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_addons_nape_FlxNapeTilemap
#include <flixel/addons/nape/FlxNapeTilemap.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawBaseItem
#include <flixel/graphics/tile/FlxDrawBaseItem.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawTilesItem
#include <flixel/graphics/tile/FlxDrawTilesItem.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxBaseTilemap
#include <flixel/tile/FlxBaseTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTile
#include <flixel/tile/FlxTile.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemap
#include <flixel/tile/FlxTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemapBuffer
#include <flixel/tile/FlxTilemapBuffer.h>
#endif
#ifndef INCLUDED_flixel_util_FlxColorTransformUtil
#include <flixel/util/FlxColorTransformUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BlendMode
#include <openfl/_legacy/display/BlendMode.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_ColorTransform
#include <openfl/_legacy/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Matrix
#include <openfl/_legacy/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Point
#include <openfl/_legacy/geom/Point.h>
#endif
#ifndef INCLUDED_world_WorldTilemap
#include <world/WorldTilemap.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_1311fef4a734501c_32_new,"world.WorldTilemap","new",0xa1abe4aa,"world.WorldTilemap.new","world/WorldTilemap.hx",32,0x450b0725)
HX_DEFINE_STACK_FRAME(_hx_pos_1311fef4a734501c_41_drawTilemap,"world.WorldTilemap","drawTilemap",0x1e2ba2d4,"world.WorldTilemap.drawTilemap","world/WorldTilemap.hx",41,0x450b0725)
namespace world{

void WorldTilemap_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_1311fef4a734501c_32_new)
            	HX_STACK_THIS(this)
HXLINE(  32)		super::__construct();
            	}

Dynamic WorldTilemap_obj::__CreateEmpty() { return new WorldTilemap_obj; }

void *WorldTilemap_obj::_hx_vtable = 0;

Dynamic WorldTilemap_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< WorldTilemap_obj > _hx_result = new WorldTilemap_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool WorldTilemap_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x25a685e0) {
		if (inClassId<=(int)0x12852d0f) {
			if (inClassId<=(int)0x088eb0ae) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x088eb0ae;
			} else {
				return inClassId==(int)0x12852d0f;
			}
		} else {
			return inClassId==(int)0x25a685e0;
		}
	} else {
		if (inClassId<=(int)0x725f80f5) {
			return inClassId==(int)0x2e105115 || inClassId==(int)0x725f80f5;
		} else {
			return inClassId==(int)0x75a66d6a;
		}
	}
}

void WorldTilemap_obj::drawTilemap( ::flixel::tile::FlxTilemapBuffer Buffer, ::flixel::FlxCamera Camera){
            	HX_GC_STACKFRAME(&_hx_pos_1311fef4a734501c_41_drawTilemap)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Buffer,"Buffer")
            	HX_STACK_ARG(Camera,"Camera")
HXLINE(  42)		HX_VAR( bool,isColored);
HXDLIN(  42)		if ((this->alpha == (int)1)) {
HXLINE(  42)			isColored = (this->color != (int)16777215);
            		}
            		else {
HXLINE(  42)			isColored = true;
            		}
HXLINE(  45)		HX_VARI( Float,drawX) = (int)0;
HXLINE(  46)		HX_VARI( Float,drawY) = (int)0;
HXLINE(  47)		HX_VARI( Float,scaledWidth) = (int)0;
HXLINE(  48)		HX_VARI( Float,scaledHeight) = (int)0;
HXLINE(  49)		HX_VARI(  ::flixel::graphics::tile::FlxDrawTilesItem,drawItem) = null();
HXLINE(  51)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(  53)			Buffer->fill(null());
            		}
            		else {
HXLINE(  57)			{
HXLINE(  57)				HX_VARI(  ::flixel::math::FlxPoint,_this) = this->getScreenPosition(this->_point,Camera)->subtractPoint(this->offset);
HXDLIN(  57)				HX_VARI(  ::openfl::_legacy::geom::Point,FlashPoint) = this->_helperPoint;
HXDLIN(  57)				if (hx::IsNull( FlashPoint )) {
HXLINE(  57)					FlashPoint =  ::openfl::_legacy::geom::Point_obj::__alloc( HX_CTX ,null(),null());
            				}
HXDLIN(  57)				FlashPoint->x = _this->x;
HXDLIN(  57)				FlashPoint->y = _this->y;
            			}
HXLINE(  59)			Float _hx_tmp;
HXDLIN(  59)			if (this->isPixelPerfectRender(Camera)) {
HXLINE(  59)				_hx_tmp = ::Math_obj::floor(this->_helperPoint->x);
            			}
            			else {
HXLINE(  59)				_hx_tmp = this->_helperPoint->x;
            			}
HXDLIN(  59)			this->_helperPoint->x = _hx_tmp;
HXLINE(  60)			Float _hx_tmp1;
HXDLIN(  60)			if (this->isPixelPerfectRender(Camera)) {
HXLINE(  60)				_hx_tmp1 = ::Math_obj::floor(this->_helperPoint->y);
            			}
            			else {
HXLINE(  60)				_hx_tmp1 = this->_helperPoint->y;
            			}
HXDLIN(  60)			this->_helperPoint->y = _hx_tmp1;
HXLINE(  62)			scaledWidth = this->_scaledTileWidth;
HXLINE(  63)			scaledHeight = this->_scaledTileHeight;
HXLINE(  65)			HX_VAR( bool,hasColorOffsets);
HXDLIN(  65)			if (hx::IsNotNull( this->colorTransform )) {
HXLINE(  65)				hasColorOffsets = ::flixel::util::FlxColorTransformUtil_obj::hasRGBAOffsets(this->colorTransform);
            			}
            			else {
HXLINE(  65)				hasColorOffsets = false;
            			}
HXLINE(  66)			drawItem = Camera->startQuadBatch(this->graphic,isColored,hasColorOffsets,this->blend,null(),null());
            		}
HXLINE(  70)		this->_point->set_x((((Camera->scroll->x * this->scrollFactor->x) - this->x) - this->offset->x));
HXLINE(  71)		this->_point->set_y((((Camera->scroll->y * this->scrollFactor->y) - this->y) - this->offset->y));
HXLINE(  73)		HX_VARI( int,screenXInTiles) = ::Math_obj::floor(((Float)this->_point->x / (Float)this->_scaledTileWidth));
HXLINE(  74)		HX_VARI( int,screenYInTiles) = ::Math_obj::floor(((Float)this->_point->y / (Float)this->_scaledTileHeight));
HXLINE(  75)		HX_VARI( int,screenRows) = Buffer->rows;
HXLINE(  76)		HX_VARI( int,screenColumns) = Buffer->columns;
HXLINE(  79)		HX_VARI(  ::Dynamic,Max) = (this->widthInTiles - screenColumns);
HXDLIN(  79)		HX_VAR( Float,lowerBound);
HXDLIN(  79)		if ((screenXInTiles < (int)0)) {
HXLINE(  79)			lowerBound = (int)0;
            		}
            		else {
HXLINE(  79)			lowerBound = screenXInTiles;
            		}
HXDLIN(  79)		Float screenXInTiles1;
HXDLIN(  79)		bool screenXInTiles2;
HXDLIN(  79)		if (hx::IsNotNull( Max )) {
HXLINE(  79)			screenXInTiles2 = hx::IsGreater( lowerBound,Max );
            		}
            		else {
HXLINE(  79)			screenXInTiles2 = false;
            		}
HXDLIN(  79)		if (screenXInTiles2) {
HXLINE(  79)			screenXInTiles1 = Max;
            		}
            		else {
HXLINE(  79)			screenXInTiles1 = lowerBound;
            		}
HXDLIN(  79)		screenXInTiles = ::Std_obj::_hx_int(screenXInTiles1);
HXLINE(  80)		HX_VARI_NAME(  ::Dynamic,Max1,"Max") = (this->heightInTiles - screenRows);
HXDLIN(  80)		HX_VAR_NAME( Float,lowerBound1,"lowerBound");
HXDLIN(  80)		if ((screenYInTiles < (int)0)) {
HXLINE(  80)			lowerBound1 = (int)0;
            		}
            		else {
HXLINE(  80)			lowerBound1 = screenYInTiles;
            		}
HXDLIN(  80)		Float screenYInTiles1;
HXDLIN(  80)		bool screenYInTiles2;
HXDLIN(  80)		if (hx::IsNotNull( Max1 )) {
HXLINE(  80)			screenYInTiles2 = hx::IsGreater( lowerBound1,Max1 );
            		}
            		else {
HXLINE(  80)			screenYInTiles2 = false;
            		}
HXDLIN(  80)		if (screenYInTiles2) {
HXLINE(  80)			screenYInTiles1 = Max1;
            		}
            		else {
HXLINE(  80)			screenYInTiles1 = lowerBound1;
            		}
HXDLIN(  80)		screenYInTiles = ::Std_obj::_hx_int(screenYInTiles1);
HXLINE(  82)		HX_VARI( int,rowIndex) = ((screenYInTiles * this->widthInTiles) + screenXInTiles);
HXLINE(  83)		this->_flashPoint->y = (int)0;
HXLINE(  84)		HX_VAR( int,columnIndex);
HXLINE(  85)		HX_VAR(  ::flixel::tile::FlxTile,tile);
HXLINE(  86)		HX_VAR(  ::flixel::graphics::frames::FlxFrame,frame);
HXLINE(  92)		{
HXLINE(  92)			HX_VARI( int,_g1) = (int)0;
HXDLIN(  92)			while((_g1 < screenRows)){
HXLINE(  92)				_g1 = (_g1 + (int)1);
HXLINE(  94)				columnIndex = rowIndex;
HXLINE(  95)				this->_flashPoint->x = (int)0;
HXLINE(  97)				{
HXLINE(  97)					HX_VARI( int,_g3) = (int)0;
HXDLIN(  97)					while((_g3 < screenColumns)){
HXLINE(  97)						_g3 = (_g3 + (int)1);
HXLINE(  99)						tile = Dynamic( this->_tileObjects->__get(this->_data->__get(columnIndex))).StaticCast<  ::flixel::tile::FlxTile >();
HXLINE( 101)						bool _hx_tmp2;
HXDLIN( 101)						bool _hx_tmp3;
HXDLIN( 101)						if (hx::IsNotNull( tile )) {
HXLINE( 101)							_hx_tmp3 = tile->visible;
            						}
            						else {
HXLINE( 101)							_hx_tmp3 = false;
            						}
HXDLIN( 101)						if (_hx_tmp3) {
HXLINE( 101)							_hx_tmp2 = (tile->frame->type != (int)2);
            						}
            						else {
HXLINE( 101)							_hx_tmp2 = false;
            						}
HXDLIN( 101)						if (_hx_tmp2) {
HXLINE( 103)							frame = tile->frame;
HXLINE( 105)							if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 107)								frame->paint(Buffer->pixels,this->_flashPoint,true,null());
            							}
            							else {
HXLINE( 136)								HX_VARI( int,helperPointX) = ::Std_obj::_hx_int(this->_helperPoint->x);
HXLINE( 137)								HX_VARI( int,helperPointY) = ::Std_obj::_hx_int(this->_helperPoint->y);
HXLINE( 138)								if ((hx::Mod(helperPointX,(int)2) != (int)0)) {
HXLINE( 140)									helperPointX = (helperPointX + (int)1);
            								}
HXLINE( 147)								if ((hx::Mod(helperPointY,(int)2) != (int)0)) {
HXLINE( 149)									helperPointY = ::Math_obj::floor(this->_helperPoint->y);
            								}
HXLINE( 151)								drawX = (helperPointX + (hx::Mod(columnIndex,this->widthInTiles) * scaledWidth));
HXLINE( 152)								drawY = (helperPointY + (::Math_obj::floor(((Float)columnIndex / (Float)this->widthInTiles)) * scaledHeight));
HXLINE( 153)								this->_matrix->identity();
HXLINE( 155)								if ((frame->angle != (int)0)) {
HXLINE( 157)									frame->prepareMatrix(this->_matrix,null(),null(),null());
            								}
HXLINE( 160)								HX_VARI( Float,scaleX) = this->scale->x;
HXLINE( 161)								HX_VARI( Float,scaleY) = this->scale->y;
HXLINE( 163)								if (this->useScaleHack) {
HXLINE( 165)									scaleX = (scaleX + ((Float)(int)1 / (Float)(frame->sourceSize->x * Camera->totalScaleX)));
HXLINE( 166)									scaleY = (scaleY + ((Float)(int)1 / (Float)(frame->sourceSize->y * Camera->totalScaleY)));
            								}
HXLINE( 168)								this->_matrix->scale(scaleX,scaleY);
HXLINE( 169)								this->_matrix->translate(drawX,drawY);
HXLINE( 171)								drawItem->addQuad(frame,this->_matrix,this->colorTransform);
            							}
            						}
HXLINE( 175)						if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 177)							 ::openfl::_legacy::geom::Point _hx_tmp4 = this->_flashPoint;
HXDLIN( 177)							_hx_tmp4->x = (_hx_tmp4->x + this->_tileWidth);
            						}
HXLINE( 179)						columnIndex = (columnIndex + (int)1);
            					}
            				}
HXLINE( 182)				if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 184)					 ::openfl::_legacy::geom::Point _hx_tmp5 = this->_flashPoint;
HXDLIN( 184)					_hx_tmp5->y = (_hx_tmp5->y + this->_tileHeight);
            				}
HXLINE( 186)				rowIndex = (rowIndex + this->widthInTiles);
            			}
            		}
HXLINE( 189)		Buffer->x = (screenXInTiles * this->_scaledTileWidth);
HXLINE( 190)		Buffer->y = (screenYInTiles * this->_scaledTileHeight);
HXLINE( 192)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 194)			if (isColored) {
HXLINE( 196)				Buffer->colorTransform(this->colorTransform);
            			}
HXLINE( 198)			Buffer->blend = this->blend;
            		}
HXLINE( 201)		Buffer->dirty = false;
            	}



hx::ObjectPtr< WorldTilemap_obj > WorldTilemap_obj::__new() {
	hx::ObjectPtr< WorldTilemap_obj > __this = new WorldTilemap_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< WorldTilemap_obj > WorldTilemap_obj::__alloc(hx::Ctx *_hx_ctx) {
	WorldTilemap_obj *__this = (WorldTilemap_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(WorldTilemap_obj), true, "world.WorldTilemap"));
	*(void **)__this = WorldTilemap_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

WorldTilemap_obj::WorldTilemap_obj()
{
}

hx::Val WorldTilemap_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"drawTilemap") ) { return hx::Val( drawTilemap_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *WorldTilemap_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *WorldTilemap_obj_sStaticStorageInfo = 0;
#endif

static ::String WorldTilemap_obj_sMemberFields[] = {
	HX_HCSTRING("drawTilemap","\x8a","\x34","\xd7","\x8e"),
	::String(null()) };

static void WorldTilemap_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(WorldTilemap_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void WorldTilemap_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(WorldTilemap_obj::__mClass,"__mClass");
};

#endif

hx::Class WorldTilemap_obj::__mClass;

void WorldTilemap_obj::__register()
{
	hx::Object *dummy = new WorldTilemap_obj;
	WorldTilemap_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("world.WorldTilemap","\xb8","\x07","\x26","\xb8");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = WorldTilemap_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(WorldTilemap_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< WorldTilemap_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = WorldTilemap_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = WorldTilemap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = WorldTilemap_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace world
