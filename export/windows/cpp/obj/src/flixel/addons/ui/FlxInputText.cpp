// Generated by Haxe 3.4.0
#include <hxcpp.h>

#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxInputText
#include <flixel/addons/ui/FlxInputText.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_text__FlxText_FlxTextAlign_Impl_
#include <flixel/text/_FlxText/FlxTextAlign_Impl_.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxRect
#include <flixel/util/FlxPool_flixel_math_FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_FlxTimer
#include <flixel/util/FlxTimer.h>
#endif
#ifndef INCLUDED_flixel_util_FlxTimerManager
#include <flixel/util/FlxTimerManager.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl__legacy_Lib
#include <openfl/_legacy/Lib.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_DisplayObject
#include <openfl/_legacy/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_DisplayObjectContainer
#include <openfl/_legacy/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_InteractiveObject
#include <openfl/_legacy/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_MovieClip
#include <openfl/_legacy/display/MovieClip.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_Sprite
#include <openfl/_legacy/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_Stage
#include <openfl/_legacy/display/Stage.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_Event
#include <openfl/_legacy/events/Event.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_EventDispatcher
#include <openfl/_legacy/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_IEventDispatcher
#include <openfl/_legacy/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_KeyboardEvent
#include <openfl/_legacy/events/KeyboardEvent.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Rectangle
#include <openfl/_legacy/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl__legacy_text_TextField
#include <openfl/_legacy/text/TextField.h>
#endif
#ifndef INCLUDED_openfl__legacy_text_TextFormat
#include <openfl/_legacy/text/TextFormat.h>
#endif
#ifndef INCLUDED_openfl_errors_Error
#include <openfl/errors/Error.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_29_new,"flixel.addons.ui.FlxInputText","new",0xf37b21c8,"flixel.addons.ui.FlxInputText.new","flixel/addons/ui/FlxInputText.hx",29,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_52_set_customFilterPattern,"flixel.addons.ui.FlxInputText","set_customFilterPattern",0x8ca18812,"flixel.addons.ui.FlxInputText.set_customFilterPattern","flixel/addons/ui/FlxInputText.hx",52,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_73_set_caretColor,"flixel.addons.ui.FlxInputText","set_caretColor",0xe765d535,"flixel.addons.ui.FlxInputText.set_caretColor","flixel/addons/ui/FlxInputText.hx",73,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_81_set_caretWidth,"flixel.addons.ui.FlxInputText","set_caretWidth",0x676c19d8,"flixel.addons.ui.FlxInputText.set_caretWidth","flixel/addons/ui/FlxInputText.hx",81,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_224_destroy,"flixel.addons.ui.FlxInputText","destroy",0x8dd65262,"flixel.addons.ui.FlxInputText.destroy","flixel/addons/ui/FlxInputText.hx",224,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_249_draw,"flixel.addons.ui.FlxInputText","draw",0x11b0159c,"flixel.addons.ui.FlxInputText.draw","flixel/addons/ui/FlxInputText.hx",249,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_270_drawSprite,"flixel.addons.ui.FlxInputText","drawSprite",0x07ac82c1,"flixel.addons.ui.FlxInputText.drawSprite","flixel/addons/ui/FlxInputText.hx",270,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_282_update,"flixel.addons.ui.FlxInputText","update",0x954505a1,"flixel.addons.ui.FlxInputText.update","flixel/addons/ui/FlxInputText.hx",282,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_306_onKeyDown,"flixel.addons.ui.FlxInputText","onKeyDown",0xeda471aa,"flixel.addons.ui.FlxInputText.onKeyDown","flixel/addons/ui/FlxInputText.hx",306,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_390_onChange,"flixel.addons.ui.FlxInputText","onChange",0x53f01d87,"flixel.addons.ui.FlxInputText.onChange","flixel/addons/ui/FlxInputText.hx",390,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_405_insertSubstring,"flixel.addons.ui.FlxInputText","insertSubstring",0xe0c1ad40,"flixel.addons.ui.FlxInputText.insertSubstring","flixel/addons/ui/FlxInputText.hx",405,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_423_getCaretIndex,"flixel.addons.ui.FlxInputText","getCaretIndex",0xfe00362d,"flixel.addons.ui.FlxInputText.getCaretIndex","flixel/addons/ui/FlxInputText.hx",423,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_434_getCharBoundaries,"flixel.addons.ui.FlxInputText","getCharBoundaries",0x38cd7cdc,"flixel.addons.ui.FlxInputText.getCharBoundaries","flixel/addons/ui/FlxInputText.hx",434,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_451_set_text,"flixel.addons.ui.FlxInputText","set_text",0x37e27742,"flixel.addons.ui.FlxInputText.set_text","flixel/addons/ui/FlxInputText.hx",451,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_498_getCharIndexAtPoint,"flixel.addons.ui.FlxInputText","getCharIndexAtPoint",0xf4438f7f,"flixel.addons.ui.FlxInputText.getCharIndexAtPoint","flixel/addons/ui/FlxInputText.hx",498,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_547_prepareCharBoundaries,"flixel.addons.ui.FlxInputText","prepareCharBoundaries",0x33edc58d,"flixel.addons.ui.FlxInputText.prepareCharBoundaries","flixel/addons/ui/FlxInputText.hx",547,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_574_onSetTextCheck,"flixel.addons.ui.FlxInputText","onSetTextCheck",0x14902030,"flixel.addons.ui.FlxInputText.onSetTextCheck","flixel/addons/ui/FlxInputText.hx",574,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_614_calcFrame,"flixel.addons.ui.FlxInputText","calcFrame",0x733ee2c0,"flixel.addons.ui.FlxInputText.calcFrame","flixel/addons/ui/FlxInputText.hx",614,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_700_toggleCaret,"flixel.addons.ui.FlxInputText","toggleCaret",0x6f59aab7,"flixel.addons.ui.FlxInputText.toggleCaret","flixel/addons/ui/FlxInputText.hx",700,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_708_filter,"flixel.addons.ui.FlxInputText","filter",0x93749f50,"flixel.addons.ui.FlxInputText.filter","flixel/addons/ui/FlxInputText.hx",708,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_736_set_params,"flixel.addons.ui.FlxInputText","set_params",0xe3d3351b,"flixel.addons.ui.FlxInputText.set_params","flixel/addons/ui/FlxInputText.hx",736,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_748_set_x,"flixel.addons.ui.FlxInputText","set_x",0x02dc16c3,"flixel.addons.ui.FlxInputText.set_x","flixel/addons/ui/FlxInputText.hx",748,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_761_set_y,"flixel.addons.ui.FlxInputText","set_y",0x02dc16c4,"flixel.addons.ui.FlxInputText.set_y","flixel/addons/ui/FlxInputText.hx",761,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_774_set_hasFocus,"flixel.addons.ui.FlxInputText","set_hasFocus",0xf91bc333,"flixel.addons.ui.FlxInputText.set_hasFocus","flixel/addons/ui/FlxInputText.hx",774,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_801_getAlignStr,"flixel.addons.ui.FlxInputText","getAlignStr",0xf6458f0a,"flixel.addons.ui.FlxInputText.getAlignStr","flixel/addons/ui/FlxInputText.hx",801,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_810_set_caretIndex,"flixel.addons.ui.FlxInputText","set_caretIndex",0x5b1dfee4,"flixel.addons.ui.FlxInputText.set_caretIndex","flixel/addons/ui/FlxInputText.hx",810,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_883_set_forceCase,"flixel.addons.ui.FlxInputText","set_forceCase",0x119aa786,"flixel.addons.ui.FlxInputText.set_forceCase","flixel/addons/ui/FlxInputText.hx",883,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_890_set_size,"flixel.addons.ui.FlxInputText","set_size",0x373c4b56,"flixel.addons.ui.FlxInputText.set_size","flixel/addons/ui/FlxInputText.hx",890,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_897_set_maxLength,"flixel.addons.ui.FlxInputText","set_maxLength",0x992e7ff5,"flixel.addons.ui.FlxInputText.set_maxLength","flixel/addons/ui/FlxInputText.hx",897,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_907_set_lines,"flixel.addons.ui.FlxInputText","set_lines",0x15ae75ca,"flixel.addons.ui.FlxInputText.set_lines","flixel/addons/ui/FlxInputText.hx",907,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_926_get_passwordMode,"flixel.addons.ui.FlxInputText","get_passwordMode",0x890c263f,"flixel.addons.ui.FlxInputText.get_passwordMode","flixel/addons/ui/FlxInputText.hx",926,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_930_set_passwordMode,"flixel.addons.ui.FlxInputText","set_passwordMode",0xdf4e13b3,"flixel.addons.ui.FlxInputText.set_passwordMode","flixel/addons/ui/FlxInputText.hx",930,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_937_set_filterMode,"flixel.addons.ui.FlxInputText","set_filterMode",0xd267a390,"flixel.addons.ui.FlxInputText.set_filterMode","flixel/addons/ui/FlxInputText.hx",937,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_944_set_fieldBorderColor,"flixel.addons.ui.FlxInputText","set_fieldBorderColor",0x31131c52,"flixel.addons.ui.FlxInputText.set_fieldBorderColor","flixel/addons/ui/FlxInputText.hx",944,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_951_set_fieldBorderThickness,"flixel.addons.ui.FlxInputText","set_fieldBorderThickness",0x8f7f3fe3,"flixel.addons.ui.FlxInputText.set_fieldBorderThickness","flixel/addons/ui/FlxInputText.hx",951,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_958_set_backgroundColor,"flixel.addons.ui.FlxInputText","set_backgroundColor",0x1e95b220,"flixel.addons.ui.FlxInputText.set_backgroundColor","flixel/addons/ui/FlxInputText.hx",958,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_31_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",31,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_32_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",32,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_33_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",33,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_34_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",34,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_35_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",35,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_37_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",37,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_38_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",38,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_39_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",39,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_41_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",41,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_42_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",42,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_43_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",43,0x19fbd1e7)
HX_DEFINE_STACK_FRAME(_hx_pos_75fddae7e64ce41a_44_boot,"flixel.addons.ui.FlxInputText","boot",0x105b6dca,"flixel.addons.ui.FlxInputText.boot","flixel/addons/ui/FlxInputText.hx",44,0x19fbd1e7)
namespace flixel{
namespace addons{
namespace ui{

void FlxInputText_obj::__construct(hx::Null< Float >  __o_X,hx::Null< Float >  __o_Y,hx::Null< int >  __o_Width,::String Text,hx::Null< int >  __o_size,hx::Null< int >  __o_TextColor,hx::Null< int >  __o_BackgroundColor,hx::Null< bool >  __o_EmbeddedFont){
Float X = __o_X.Default(0);
Float Y = __o_Y.Default(0);
int Width = __o_Width.Default(150);
int size = __o_size.Default(8);
int TextColor = __o_TextColor.Default(-16777216);
int BackgroundColor = __o_BackgroundColor.Default(-1);
bool EmbeddedFont = __o_EmbeddedFont.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_75fddae7e64ce41a_29_new)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(X,"X")
            	HX_STACK_ARG(Y,"Y")
            	HX_STACK_ARG(Width,"Width")
            	HX_STACK_ARG(Text,"Text")
            	HX_STACK_ARG(size,"size")
            	HX_STACK_ARG(TextColor,"TextColor")
            	HX_STACK_ARG(BackgroundColor,"BackgroundColor")
            	HX_STACK_ARG(EmbeddedFont,"EmbeddedFont")
HXLINE( 164)		this->_scrollBoundIndeces =  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("right",dc,0b,64,e9),(int)0)
            			->setFixed(1,HX_("left",07,08,b0,47),(int)0));
HXLINE( 139)		this->backgroundColor = (int)-1;
HXLINE( 134)		this->fieldBorderThickness = (int)1;
HXLINE( 129)		this->fieldBorderColor = (int)-16777216;
HXLINE( 124)		this->filterMode = (int)0;
HXLINE( 113)		this->maxLength = (int)0;
HXLINE( 107)		this->forceCase = (int)0;
HXLINE( 102)		this->caretIndex = (int)0;
HXLINE(  97)		this->hasFocus = false;
HXLINE(  79)		this->caretWidth = (int)1;
HXLINE(  66)		this->background = false;
HXLINE( 186)		super::__construct(X,Y,Width,Text,size,EmbeddedFont);
HXLINE( 187)		this->set_backgroundColor(BackgroundColor);
HXLINE( 189)		if ((BackgroundColor != (int)0)) {
HXLINE( 191)			this->background = true;
            		}
HXLINE( 194)		this->set_color(TextColor);
HXLINE( 195)		this->set_caretColor(TextColor);
HXLINE( 197)		this->caret =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE( 198)		 ::flixel::FlxSprite _hx_tmp = this->caret;
HXDLIN( 198)		int _hx_tmp1 = this->caretWidth;
HXDLIN( 198)		_hx_tmp->makeGraphic(_hx_tmp1,::Std_obj::_hx_int((size + (int)2)),null(),null(),null());
HXLINE( 199)		this->_caretTimer =  ::flixel::util::FlxTimer_obj::__alloc( HX_CTX ,null());
HXLINE( 201)		this->set_caretIndex((int)0);
HXLINE( 202)		this->set_hasFocus(false);
HXLINE( 203)		if (this->background) {
HXLINE( 204)			this->fieldBorderSprite =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,X,Y,null());
HXLINE( 205)			this->backgroundSprite =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,X,Y,null());
            		}
HXLINE( 208)		this->set_lines((int)1);
HXLINE( 209)		::openfl::_legacy::Lib_obj::get_current()->get_stage()->addEventListener(::openfl::_legacy::events::KeyboardEvent_obj::KEY_DOWN,this->onKeyDown_dyn(),null(),null(),null());
HXLINE( 211)		if (hx::IsNull( Text )) {
HXLINE( 212)			Text = HX_("",00,00,00,00);
            		}
HXLINE( 215)		this->set_text(Text);
HXLINE( 217)		this->calcFrame(null());
            	}

Dynamic FlxInputText_obj::__CreateEmpty() { return new FlxInputText_obj; }

void *FlxInputText_obj::_hx_vtable = 0;

Dynamic FlxInputText_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxInputText_obj > _hx_result = new FlxInputText_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7]);
	return _hx_result;
}

bool FlxInputText_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2e105115) {
		if (inClassId<=(int)0x25a685e0) {
			if (inClassId<=(int)0x0b6ffd77) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0b6ffd77;
			} else {
				return inClassId==(int)0x25a685e0;
			}
		} else {
			return inClassId==(int)0x2e105115;
		}
	} else {
		return inClassId==(int)0x4d1b55ae || inClassId==(int)0x6fc11e2c;
	}
}

 ::EReg FlxInputText_obj::set_customFilterPattern( ::EReg cfp){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_52_set_customFilterPattern)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(cfp,"cfp")
HXLINE(  53)		this->customFilterPattern = cfp;
HXLINE(  54)		this->set_filterMode((int)4);
HXLINE(  55)		return this->customFilterPattern;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_customFilterPattern,return )

int FlxInputText_obj::set_caretColor(int i){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_73_set_caretColor)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(i,"i")
HXLINE(  74)		this->caretColor = i;
HXLINE(  75)		this->dirty = true;
HXLINE(  76)		return this->caretColor;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_caretColor,return )

int FlxInputText_obj::set_caretWidth(int i){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_81_set_caretWidth)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(i,"i")
HXLINE(  82)		this->caretWidth = i;
HXLINE(  83)		this->dirty = true;
HXLINE(  84)		return this->caretWidth;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_caretWidth,return )

void FlxInputText_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_224_destroy)
            	HX_STACK_THIS(this)
HXLINE( 225)		::openfl::_legacy::Lib_obj::get_current()->get_stage()->removeEventListener(::openfl::_legacy::events::KeyboardEvent_obj::KEY_DOWN,this->onKeyDown_dyn(),null());
HXLINE( 227)		this->backgroundSprite = ( ( ::flixel::FlxSprite)(::flixel::util::FlxDestroyUtil_obj::destroy(this->backgroundSprite)) );
HXLINE( 228)		this->fieldBorderSprite = ( ( ::flixel::FlxSprite)(::flixel::util::FlxDestroyUtil_obj::destroy(this->fieldBorderSprite)) );
HXLINE( 229)		this->callback = null();
HXLINE( 232)		if (hx::IsNotNull( this->_charBoundaries )) {
HXLINE( 234)			while((this->_charBoundaries->length > (int)0)){
HXLINE( 236)				this->_charBoundaries->pop().StaticCast<  ::flixel::math::FlxRect >();
            			}
HXLINE( 238)			this->_charBoundaries = null();
            		}
HXLINE( 242)		this->super::destroy();
            	}


void FlxInputText_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_249_draw)
            	HX_STACK_THIS(this)
HXLINE( 250)		this->drawSprite(this->fieldBorderSprite);
HXLINE( 251)		this->drawSprite(this->backgroundSprite);
HXLINE( 253)		this->super::draw();
HXLINE( 256)		bool _hx_tmp;
HXDLIN( 256)		if ((this->caretColor == this->caret->color)) {
HXLINE( 256)			Float _hx_tmp1 = this->caret->get_height();
HXDLIN( 256)			_hx_tmp = (_hx_tmp1 != (::Std_obj::_hx_int(this->_defaultFormat->size) + (int)2));
            		}
            		else {
HXLINE( 256)			_hx_tmp = true;
            		}
HXDLIN( 256)		if (_hx_tmp) {
HXLINE( 258)			this->caret->set_color(this->caretColor);
            		}
HXLINE( 261)		this->drawSprite(this->caret);
            	}


void FlxInputText_obj::drawSprite( ::flixel::FlxSprite Sprite){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_270_drawSprite)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Sprite,"Sprite")
HXLINE( 270)		bool _hx_tmp;
HXDLIN( 270)		if (hx::IsNotNull( Sprite )) {
HXLINE( 270)			_hx_tmp = Sprite->visible;
            		}
            		else {
HXLINE( 270)			_hx_tmp = false;
            		}
HXDLIN( 270)		if (_hx_tmp) {
HXLINE( 272)			Sprite->scrollFactor = this->scrollFactor;
HXLINE( 273)			Sprite->set_cameras(this->get_cameras());
HXLINE( 274)			Sprite->draw();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,drawSprite,(void))

void FlxInputText_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_282_update)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(elapsed,"elapsed")
HXLINE( 283)		this->super::update(elapsed);
HXLINE( 287)		if ((::flixel::FlxG_obj::mouse->_leftButton->current == (int)2)) {
HXLINE( 289)			if (::flixel::FlxG_obj::mouse->overlaps(hx::ObjectPtr<OBJ_>(this),null())) {
HXLINE( 291)				this->set_caretIndex(this->getCaretIndex());
HXLINE( 292)				this->set_hasFocus(true);
            			}
            			else {
HXLINE( 296)				this->set_hasFocus(false);
            			}
            		}
            	}


void FlxInputText_obj::onKeyDown( ::openfl::_legacy::events::KeyboardEvent e){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_306_onKeyDown)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(e,"e")
HXLINE( 307)		HX_VARI( int,key) = e->keyCode;
HXLINE( 309)		if (this->hasFocus) {
HXLINE( 312)			bool _hx_tmp;
HXDLIN( 312)			bool _hx_tmp1;
HXDLIN( 312)			bool _hx_tmp2;
HXDLIN( 312)			if ((key != (int)16)) {
HXLINE( 312)				_hx_tmp2 = (key == (int)17);
            			}
            			else {
HXLINE( 312)				_hx_tmp2 = true;
            			}
HXDLIN( 312)			if (!(_hx_tmp2)) {
HXLINE( 312)				_hx_tmp1 = (key == (int)220);
            			}
            			else {
HXLINE( 312)				_hx_tmp1 = true;
            			}
HXDLIN( 312)			if (!(_hx_tmp1)) {
HXLINE( 312)				_hx_tmp = (key == (int)27);
            			}
            			else {
HXLINE( 312)				_hx_tmp = true;
            			}
HXDLIN( 312)			if (_hx_tmp) {
HXLINE( 314)				return;
            			}
            			else {
HXLINE( 317)				if ((key == (int)37)) {
HXLINE( 319)					if ((this->caretIndex > (int)0)) {
HXLINE( 320)						{
HXLINE( 320)							HX_VARI(  ::flixel::addons::ui::FlxInputText,_g) = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 320)							_g->set_caretIndex((_g->caretIndex - (int)1));
            						}
HXLINE( 321)						this->set_text(this->text);
            					}
            				}
            				else {
HXLINE( 325)					if ((key == (int)39)) {
HXLINE( 327)						if ((this->caretIndex < this->text.length)) {
HXLINE( 328)							{
HXLINE( 328)								HX_VARI_NAME(  ::flixel::addons::ui::FlxInputText,_g1,"_g") = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 328)								_g1->set_caretIndex((_g1->caretIndex + (int)1));
            							}
HXLINE( 329)							this->set_text(this->text);
            						}
            					}
            					else {
HXLINE( 333)						if ((key == (int)35)) {
HXLINE( 335)							this->set_caretIndex(this->text.length);
HXLINE( 336)							this->set_text(this->text);
            						}
            						else {
HXLINE( 339)							if ((key == (int)36)) {
HXLINE( 341)								this->set_caretIndex((int)0);
HXLINE( 342)								this->set_text(this->text);
            							}
            							else {
HXLINE( 345)								if ((key == (int)8)) {
HXLINE( 347)									if ((this->caretIndex > (int)0)) {
HXLINE( 350)										{
HXLINE( 350)											HX_VARI_NAME(  ::flixel::addons::ui::FlxInputText,_g2,"_g") = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 350)											_g2->set_caretIndex((_g2->caretIndex - (int)1));
            										}
HXLINE( 351)										::String _hx_tmp3 = this->text.substring((int)0,this->caretIndex);
HXDLIN( 351)										this->set_text((_hx_tmp3 + this->text.substring((this->caretIndex + (int)1),null())));
HXLINE( 352)										this->onChange(HX_("backspace",3f,85,ea,ca));
            									}
            								}
            								else {
HXLINE( 356)									if ((key == (int)46)) {
HXLINE( 358)										bool _hx_tmp4;
HXDLIN( 358)										if ((this->text.length > (int)0)) {
HXLINE( 358)											_hx_tmp4 = (this->caretIndex < this->text.length);
            										}
            										else {
HXLINE( 358)											_hx_tmp4 = false;
            										}
HXDLIN( 358)										if (_hx_tmp4) {
HXLINE( 360)											::String _hx_tmp5 = this->text.substring((int)0,this->caretIndex);
HXDLIN( 360)											this->set_text((_hx_tmp5 + this->text.substring((this->caretIndex + (int)1),null())));
HXLINE( 361)											this->onChange(HX_("delete",2b,c0,d8,6a));
            										}
            									}
            									else {
HXLINE( 365)										if ((key == (int)13)) {
HXLINE( 367)											this->onChange(HX_("enter",18,6d,86,70));
            										}
            										else {
HXLINE( 372)											if ((e->charCode == (int)0)) {
HXLINE( 374)												return;
            											}
HXLINE( 376)											HX_VARI( ::String,newText) = this->filter(::String::fromCharCode(e->charCode));
HXLINE( 378)											bool _hx_tmp6;
HXDLIN( 378)											if ((newText.length > (int)0)) {
HXLINE( 378)												if ((this->maxLength != (int)0)) {
HXLINE( 378)													_hx_tmp6 = ((this->text.length + newText.length) < this->maxLength);
            												}
            												else {
HXLINE( 378)													_hx_tmp6 = true;
            												}
            											}
            											else {
HXLINE( 378)												_hx_tmp6 = false;
            											}
HXDLIN( 378)											if (_hx_tmp6) {
HXLINE( 380)												this->set_text(this->insertSubstring(this->text,newText,this->caretIndex));
HXLINE( 381)												{
HXLINE( 381)													HX_VARI_NAME(  ::flixel::addons::ui::FlxInputText,_g3,"_g") = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 381)													_g3->set_caretIndex((_g3->caretIndex + (int)1));
            												}
HXLINE( 382)												this->onChange(HX_("input",0a,c4,1d,be));
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,onKeyDown,(void))

void FlxInputText_obj::onChange(::String action){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_390_onChange)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(action,"action")
HXLINE( 390)		if (hx::IsNotNull( this->callback )) {
HXLINE( 392)			this->callback(this->text,action);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,onChange,(void))

::String FlxInputText_obj::insertSubstring(::String Original,::String Insert,int Index){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_405_insertSubstring)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Original,"Original")
            	HX_STACK_ARG(Insert,"Insert")
            	HX_STACK_ARG(Index,"Index")
HXLINE( 406)		if ((Index != Original.length)) {
HXLINE( 408)			HX_VARI_NAME( ::String,Original1,"Original") = (Original.substring((int)0,Index) + Insert);
HXDLIN( 408)			Original = (Original1 + Original.substring(Index,null()));
            		}
            		else {
HXLINE( 412)			Original = (Original + Insert);
            		}
HXLINE( 414)		return Original;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxInputText_obj,insertSubstring,return )

int FlxInputText_obj::getCaretIndex(){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_423_getCaretIndex)
            	HX_STACK_THIS(this)
HXLINE( 425)		Float X = (::flixel::FlxG_obj::mouse->x - this->x);
HXDLIN( 425)		Float Y = (::flixel::FlxG_obj::mouse->y - this->y);
HXDLIN( 425)		HX_VARI(  ::flixel::math::FlxPoint,point) = ::flixel::math::FlxPoint_obj::_pool->get()->set(X,Y);
HXDLIN( 425)		point->_inPool = false;
HXLINE( 426)		return this->getCharIndexAtPoint(point->x,point->y);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxInputText_obj,getCaretIndex,return )

 ::openfl::_legacy::geom::Rectangle FlxInputText_obj::getCharBoundaries(int charIndex){
            	HX_GC_STACKFRAME(&_hx_pos_75fddae7e64ce41a_434_getCharBoundaries)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(charIndex,"charIndex")
HXLINE( 435)		bool _hx_tmp;
HXDLIN( 435)		bool _hx_tmp1;
HXDLIN( 435)		if (hx::IsNotNull( this->_charBoundaries )) {
HXLINE( 435)			_hx_tmp1 = (charIndex >= (int)0);
            		}
            		else {
HXLINE( 435)			_hx_tmp1 = false;
            		}
HXDLIN( 435)		if (_hx_tmp1) {
HXLINE( 435)			_hx_tmp = (this->_charBoundaries->length > (int)0);
            		}
            		else {
HXLINE( 435)			_hx_tmp = false;
            		}
HXDLIN( 435)		if (_hx_tmp) {
HXLINE( 437)			HX_VARI(  ::openfl::_legacy::geom::Rectangle,r) =  ::openfl::_legacy::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 438)			if ((charIndex >= this->_charBoundaries->length)) {
HXLINE( 440)				HX_VARI(  ::flixel::math::FlxRect,_this) = this->_charBoundaries->__get((this->_charBoundaries->length - (int)1)).StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 440)				HX_VARI(  ::openfl::_legacy::geom::Rectangle,FlashRect) = r;
HXDLIN( 440)				if (hx::IsNull( r )) {
HXLINE( 440)					FlashRect =  ::openfl::_legacy::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            				}
HXDLIN( 440)				FlashRect->x = _this->x;
HXDLIN( 440)				FlashRect->y = _this->y;
HXDLIN( 440)				FlashRect->width = _this->width;
HXDLIN( 440)				FlashRect->height = _this->height;
            			}
            			else {
HXLINE( 443)				HX_VARI_NAME(  ::flixel::math::FlxRect,_this1,"_this") = this->_charBoundaries->__get(charIndex).StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 443)				HX_VARI_NAME(  ::openfl::_legacy::geom::Rectangle,FlashRect1,"FlashRect") = r;
HXDLIN( 443)				if (hx::IsNull( r )) {
HXLINE( 443)					FlashRect1 =  ::openfl::_legacy::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            				}
HXDLIN( 443)				FlashRect1->x = _this1->x;
HXDLIN( 443)				FlashRect1->y = _this1->y;
HXDLIN( 443)				FlashRect1->width = _this1->width;
HXDLIN( 443)				FlashRect1->height = _this1->height;
            			}
HXLINE( 445)			return r;
            		}
HXLINE( 447)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,getCharBoundaries,return )

::String FlxInputText_obj::set_text(::String Text){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_451_set_text)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Text,"Text")
HXLINE( 453)		if (hx::IsNotNull( this->textField )) {
HXLINE( 455)			this->lastScroll = this->textField->get_scrollH();
            		}
HXLINE( 458)		HX_VARI( ::String,return_text) = this->super::set_text(Text);
HXLINE( 460)		if (hx::IsNull( this->textField )) {
HXLINE( 462)			return return_text;
            		}
HXLINE( 465)		HX_VARI( int,numChars) = Text.length;
HXLINE( 466)		this->prepareCharBoundaries(numChars);
HXLINE( 467)		this->textField->set_text(HX_("",00,00,00,00));
HXLINE( 468)		HX_VARI( Float,textH) = (int)0;
HXLINE( 469)		HX_VARI( Float,textW) = (int)0;
HXLINE( 470)		HX_VARI( Float,lastW) = (int)0;
HXLINE( 475)		HX_VARI( Float,magicX) = (int)2;
HXLINE( 476)		HX_VARI( Float,magicY) = (int)2;
HXLINE( 478)		{
HXLINE( 478)			HX_VARI( int,_g1) = (int)0;
HXDLIN( 478)			while((_g1 < numChars)){
HXLINE( 478)				_g1 = (_g1 + (int)1);
HXDLIN( 478)				HX_VARI( int,i) = (_g1 - (int)1);
HXLINE( 480)				 ::openfl::_legacy::text::TextField _hx_tmp = this->textField;
HXDLIN( 480)				_hx_tmp->appendText(Text.substr(i,(int)1));
HXLINE( 481)				textW = this->textField->get_textWidth();
HXLINE( 482)				if ((i == (int)0)) {
HXLINE( 484)					textH = this->textField->get_textHeight();
            				}
HXLINE( 486)				this->_charBoundaries->__get(i).StaticCast<  ::flixel::math::FlxRect >()->x = (magicX + lastW);
HXLINE( 487)				this->_charBoundaries->__get(i).StaticCast<  ::flixel::math::FlxRect >()->y = magicY;
HXLINE( 488)				this->_charBoundaries->__get(i).StaticCast<  ::flixel::math::FlxRect >()->width = (textW - lastW);
HXLINE( 489)				this->_charBoundaries->__get(i).StaticCast<  ::flixel::math::FlxRect >()->height = textH;
HXLINE( 490)				lastW = textW;
            			}
            		}
HXLINE( 492)		this->textField->set_text(Text);
HXLINE( 493)		this->onSetTextCheck();
HXLINE( 494)		return return_text;
            	}


int FlxInputText_obj::getCharIndexAtPoint(Float X,Float Y){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_498_getCharIndexAtPoint)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(X,"X")
            	HX_STACK_ARG(Y,"Y")
HXLINE( 499)		HX_VARI( int,i) = (int)0;
HXLINE( 501)		X = (X + (this->textField->get_scrollH() + (int)2));
HXLINE( 506)		bool _hx_tmp;
HXDLIN( 506)		if (hx::IsNotNull( this->_charBoundaries )) {
HXLINE( 506)			_hx_tmp = (this->_charBoundaries->length > (int)0);
            		}
            		else {
HXLINE( 506)			_hx_tmp = false;
            		}
HXDLIN( 506)		if (_hx_tmp) {
HXLINE( 508)			Float _hx_tmp1 = this->textField->get_textWidth();
HXDLIN( 508)			if ((_hx_tmp1 <= this->textField->get_width())) {
HXLINE( 509)				::String _hx_switch_0 = this->getAlignStr();
            				if (  (_hx_switch_0==HX_("center",d5,25,db,05)) ){
HXLINE( 514)					HX_VARI_NAME( Float,X1,"X") = (X - ((Float)this->textField->get_width() / (Float)(int)2));
HXDLIN( 514)					X = (X1 + ((Float)this->textField->get_textWidth() / (Float)(int)2));
HXDLIN( 514)					goto _hx_goto_16;
            				}
            				if (  (_hx_switch_0==HX_("right",dc,0b,64,e9)) ){
HXLINE( 512)					HX_VARI_NAME( Float,X2,"X") = (X - this->textField->get_width());
HXDLIN( 512)					X = (X2 + this->textField->get_textWidth());
HXDLIN( 512)					goto _hx_goto_16;
            				}
            				/* default */{
            				}
            				_hx_goto_16:;
            			}
            		}
HXLINE( 521)		if (hx::IsNotNull( this->_charBoundaries )) {
HXLINE( 523)			HX_VARI( int,_g) = (int)0;
HXDLIN( 523)			HX_VARI( ::Array< ::Dynamic>,_g1) = this->_charBoundaries;
HXDLIN( 523)			while((_g < _g1->length)){
HXLINE( 523)				HX_VARI(  ::flixel::math::FlxRect,r) = _g1->__get(_g).StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 523)				_g = (_g + (int)1);
HXLINE( 525)				bool _hx_tmp2;
HXDLIN( 525)				if ((X >= r->x)) {
HXLINE( 525)					_hx_tmp2 = (X <= (r->x + r->width));
            				}
            				else {
HXLINE( 525)					_hx_tmp2 = false;
            				}
HXDLIN( 525)				if (_hx_tmp2) {
HXLINE( 527)					return i;
            				}
HXLINE( 529)				i = (i + (int)1);
            			}
            		}
HXLINE( 534)		bool _hx_tmp3;
HXDLIN( 534)		if (hx::IsNotNull( this->_charBoundaries )) {
HXLINE( 534)			_hx_tmp3 = (this->_charBoundaries->length > (int)0);
            		}
            		else {
HXLINE( 534)			_hx_tmp3 = false;
            		}
HXDLIN( 534)		if (_hx_tmp3) {
HXLINE( 536)			if ((X > this->textField->get_textWidth())) {
HXLINE( 538)				return this->_charBoundaries->length;
            			}
            		}
HXLINE( 543)		return (int)-1;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxInputText_obj,getCharIndexAtPoint,return )

void FlxInputText_obj::prepareCharBoundaries(int numChars){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_547_prepareCharBoundaries)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(numChars,"numChars")
HXLINE( 548)		if (hx::IsNull( this->_charBoundaries )) {
HXLINE( 550)			this->_charBoundaries = ::Array_obj< ::Dynamic>::__new(0);
            		}
HXLINE( 553)		if ((this->_charBoundaries->length > numChars)) {
HXLINE( 555)			HX_VARI( int,diff) = (this->_charBoundaries->length - numChars);
HXLINE( 556)			{
HXLINE( 556)				HX_VARI( int,_g1) = (int)0;
HXDLIN( 556)				while((_g1 < diff)){
HXLINE( 556)					_g1 = (_g1 + (int)1);
HXLINE( 558)					this->_charBoundaries->pop().StaticCast<  ::flixel::math::FlxRect >();
            				}
            			}
            		}
HXLINE( 562)		{
HXLINE( 562)			HX_VARI_NAME( int,_g11,"_g1") = (int)0;
HXDLIN( 562)			while((_g11 < numChars)){
HXLINE( 562)				_g11 = (_g11 + (int)1);
HXLINE( 564)				if (((this->_charBoundaries->length - (int)1) < (_g11 - (int)1))) {
HXLINE( 566)					::Array< ::Dynamic> _hx_tmp = this->_charBoundaries;
HXDLIN( 566)					HX_VARI(  ::flixel::math::FlxRect,_this) = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 566)					_this->x = (int)0;
HXDLIN( 566)					_this->y = (int)0;
HXDLIN( 566)					_this->width = (int)0;
HXDLIN( 566)					_this->height = (int)0;
HXDLIN( 566)					_this->_inPool = false;
HXDLIN( 566)					_hx_tmp->push(_this);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,prepareCharBoundaries,(void))

void FlxInputText_obj::onSetTextCheck(){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_574_onSetTextCheck)
            	HX_STACK_THIS(this)
HXLINE( 576)		HX_VARI(  ::openfl::_legacy::geom::Rectangle,boundary) = null();
HXLINE( 577)		if ((this->caretIndex == (int)-1)) {
HXLINE( 579)			boundary = this->getCharBoundaries((this->text.length - (int)1));
            		}
            		else {
HXLINE( 582)			boundary = this->getCharBoundaries(this->caretIndex);
            		}
HXLINE( 585)		if (hx::IsNotNull( boundary )) {
HXLINE( 588)			HX_VARI( int,diffW) = (int)0;
HXLINE( 589)			Float _hx_tmp = boundary->get_right();
HXDLIN( 589)			int _hx_tmp1 = this->lastScroll;
HXDLIN( 589)			if ((_hx_tmp > ((_hx_tmp1 + this->textField->get_width()) - (int)2))) {
HXLINE( 591)				HX_VARI_NAME( Float,diffW1,"diffW") = (this->textField->get_width() - (int)2);
HXDLIN( 591)				diffW = -(::Std_obj::_hx_int((diffW1 - boundary->get_right())));
            			}
            			else {
HXLINE( 592)				if ((boundary->get_left() < this->lastScroll)) {
HXLINE( 594)					diffW = (::Std_obj::_hx_int(boundary->get_left()) - (int)2);
            				}
            				else {
HXLINE( 597)					diffW = this->lastScroll;
            				}
            			}
HXLINE( 601)			this->textField->set_scrollH(diffW);
HXLINE( 603)			this->calcFrame(null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxInputText_obj,onSetTextCheck,(void))

void FlxInputText_obj::calcFrame(hx::Null< bool >  __o_RunOnCpp){
bool RunOnCpp = __o_RunOnCpp.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_75fddae7e64ce41a_614_calcFrame)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(RunOnCpp,"RunOnCpp")
HXLINE( 615)		this->super::calcFrame(RunOnCpp);
HXLINE( 617)		if (hx::IsNotNull( this->fieldBorderSprite )) {
HXLINE( 619)			if ((this->fieldBorderThickness > (int)0)) {
HXLINE( 621)				 ::flixel::FlxSprite _hx_tmp = this->fieldBorderSprite;
HXDLIN( 621)				Float _hx_tmp1 = this->get_width();
HXDLIN( 621)				int _hx_tmp2 = ::Std_obj::_hx_int((_hx_tmp1 + (this->fieldBorderThickness * (int)2)));
HXDLIN( 621)				Float _hx_tmp3 = this->get_height();
HXDLIN( 621)				int _hx_tmp4 = ::Std_obj::_hx_int((_hx_tmp3 + (this->fieldBorderThickness * (int)2)));
HXDLIN( 621)				_hx_tmp->makeGraphic(_hx_tmp2,_hx_tmp4,this->fieldBorderColor,null(),null());
HXLINE( 622)				this->fieldBorderSprite->set_x((this->x - this->fieldBorderThickness));
HXLINE( 623)				this->fieldBorderSprite->set_y((this->y - this->fieldBorderThickness));
            			}
            			else {
HXLINE( 625)				if ((this->fieldBorderThickness == (int)0)) {
HXLINE( 627)					this->fieldBorderSprite->set_visible(false);
            				}
            			}
            		}
HXLINE( 631)		if (hx::IsNotNull( this->backgroundSprite )) {
HXLINE( 633)			if (this->background) {
HXLINE( 635)				 ::flixel::FlxSprite _hx_tmp5 = this->backgroundSprite;
HXDLIN( 635)				int _hx_tmp6 = ::Std_obj::_hx_int(this->get_width());
HXDLIN( 635)				int _hx_tmp7 = ::Std_obj::_hx_int(this->get_height());
HXDLIN( 635)				_hx_tmp5->makeGraphic(_hx_tmp6,_hx_tmp7,this->backgroundColor,null(),null());
HXLINE( 636)				this->backgroundSprite->set_x(this->x);
HXLINE( 637)				this->backgroundSprite->set_y(this->y);
            			}
            			else {
HXLINE( 641)				this->backgroundSprite->set_visible(false);
            			}
            		}
HXLINE( 645)		if (hx::IsNotNull( this->caret )) {
HXLINE( 650)			HX_VARI( int,cw) = this->caretWidth;
HXLINE( 651)			HX_VARI( int,ch) = ::Std_obj::_hx_int((::Std_obj::_hx_int(this->_defaultFormat->size) + (int)2));
HXLINE( 654)			HX_VARI( int,borderC) = ((int)(int)-16777216 | (int)((int)this->borderColor & (int)(int)16777215));
HXLINE( 655)			HX_VARI( int,caretC) = ((int)(int)-16777216 | (int)((int)this->caretColor & (int)(int)16777215));
HXLINE( 658)			::String caretKey = ((((((((HX_("caret",83,f9,1f,41) + cw) + HX_("x",78,00,00,00)) + ch) + HX_("c:",77,56,00,00)) + caretC) + HX_("b:",98,55,00,00)) + ::Std_obj::string(this->borderStyle)) + HX_(",",2c,00,00,00));
HXDLIN( 658)			HX_VARI_NAME( ::String,caretKey1,"caretKey") = (((caretKey + this->borderSize) + HX_(",",2c,00,00,00)) + borderC);
HXLINE( 659)			switch((int)(_hx_getEnumValueIndex(this->borderStyle))){
            				case (int)0: {
HXLINE( 663)					this->caret->makeGraphic(cw,ch,caretC,false,caretKey1);
HXLINE( 664)					 ::flixel::math::FlxPoint _hx_tmp8 = this->caret->offset;
HXDLIN( 664)					_hx_tmp8->set_x(this->caret->offset->set_y((int)0));
            				}
            				break;
            				case (int)1: {
HXLINE( 668)					cw = (cw + ::Std_obj::_hx_int(this->borderSize));
HXLINE( 669)					ch = (ch + ::Std_obj::_hx_int(this->borderSize));
HXLINE( 670)					this->caret->makeGraphic(cw,ch,(int)0,false,caretKey1);
HXLINE( 671)					HX_VARI( Float,r) = this->borderSize;
HXDLIN( 671)					HX_VARI_NAME( Float,r1,"r") = this->borderSize;
HXDLIN( 671)					HX_VARI_NAME( int,r2,"r") = this->caretWidth;
HXDLIN( 671)					HX_VARI_NAME(  ::openfl::_legacy::geom::Rectangle,r3,"r") =  ::openfl::_legacy::geom::Rectangle_obj::__alloc( HX_CTX ,r,r1,r2,::Std_obj::_hx_int((::Std_obj::_hx_int(this->_defaultFormat->size) + (int)2)));
HXLINE( 672)					this->caret->get_pixels()->fillRect(r3,borderC);
HXLINE( 673)					r3->x = (r3->y = (int)0);
HXLINE( 674)					this->caret->get_pixels()->fillRect(r3,caretC);
HXLINE( 675)					 ::flixel::math::FlxPoint _hx_tmp9 = this->caret->offset;
HXDLIN( 675)					_hx_tmp9->set_x(this->caret->offset->set_y((int)0));
            				}
            				break;
            				case (int)2: case (int)3: {
HXLINE( 679)					cw = (cw + ::Std_obj::_hx_int((this->borderSize * (int)2)));
HXLINE( 680)					ch = (ch + ::Std_obj::_hx_int((this->borderSize * (int)2)));
HXLINE( 681)					this->caret->makeGraphic(cw,ch,borderC,false,caretKey1);
HXLINE( 682)					HX_VARI_NAME( Float,r4,"r") = this->borderSize;
HXDLIN( 682)					HX_VARI_NAME( Float,r5,"r") = this->borderSize;
HXDLIN( 682)					HX_VARI_NAME( int,r6,"r") = this->caretWidth;
HXDLIN( 682)					HX_VARI_NAME(  ::openfl::_legacy::geom::Rectangle,r7,"r") =  ::openfl::_legacy::geom::Rectangle_obj::__alloc( HX_CTX ,r4,r5,r6,::Std_obj::_hx_int((::Std_obj::_hx_int(this->_defaultFormat->size) + (int)2)));
HXLINE( 683)					this->caret->get_pixels()->fillRect(r7,caretC);
HXLINE( 685)					 ::flixel::math::FlxPoint _hx_tmp10 = this->caret->offset;
HXDLIN( 685)					_hx_tmp10->set_x(this->caret->offset->set_y(this->borderSize));
            				}
            				break;
            			}
HXLINE( 688)			this->caret->set_width(cw);
HXLINE( 689)			this->caret->set_height(ch);
HXLINE( 691)			this->set_caretIndex(this->caretIndex);
            		}
            	}


void FlxInputText_obj::toggleCaret( ::flixel::util::FlxTimer timer){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_700_toggleCaret)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(timer,"timer")
HXLINE( 700)		this->caret->set_visible(!(this->caret->visible));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,toggleCaret,(void))

::String FlxInputText_obj::filter(::String text){
            	HX_GC_STACKFRAME(&_hx_pos_75fddae7e64ce41a_708_filter)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(text,"text")
HXLINE( 709)		if ((this->forceCase == (int)1)) {
HXLINE( 711)			text = text.toUpperCase();
            		}
            		else {
HXLINE( 713)			if ((this->forceCase == (int)2)) {
HXLINE( 715)				text = text.toLowerCase();
            			}
            		}
HXLINE( 718)		if ((this->filterMode != (int)0)) {
HXLINE( 720)			HX_VAR(  ::EReg,pattern);
HXLINE( 721)			switch((int)(this->filterMode)){
            				case (int)1: {
HXLINE( 723)					pattern =  ::EReg_obj::__alloc( HX_CTX ,HX_("[^a-zA-Z]*",50,38,19,1d),HX_("g",67,00,00,00));
            				}
            				break;
            				case (int)2: {
HXLINE( 724)					pattern =  ::EReg_obj::__alloc( HX_CTX ,HX_("[^0-9]*",46,25,d3,1e),HX_("g",67,00,00,00));
            				}
            				break;
            				case (int)3: {
HXLINE( 725)					pattern =  ::EReg_obj::__alloc( HX_CTX ,HX_("[^a-zA-Z0-9]*",86,f4,79,aa),HX_("g",67,00,00,00));
            				}
            				break;
            				case (int)4: {
HXLINE( 726)					pattern = this->customFilterPattern;
            				}
            				break;
            				default:{
HXLINE( 728)					HX_STACK_DO_THROW( ::openfl::errors::Error_obj::__alloc( HX_CTX ,((HX_("FlxInputText: Unknown filterMode (",04,c7,17,56) + this->filterMode) + HX_(")",29,00,00,00)),null()));
            				}
            			}
HXLINE( 730)			text = pattern->replace(text,HX_("",00,00,00,00));
            		}
HXLINE( 732)		return text;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,filter,return )

::cpp::VirtualArray FlxInputText_obj::set_params(::cpp::VirtualArray p){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_736_set_params)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(p,"p")
HXLINE( 737)		this->params = p;
HXLINE( 738)		if (hx::IsNull( this->params )) {
HXLINE( 740)			this->params = ::cpp::VirtualArray_obj::__new(0);
            		}
HXLINE( 743)		this->params->push( ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("value",71,7f,b8,31),this->text)
            			->setFixed(1,HX_("name",4b,72,ff,48),HX_("value",71,7f,b8,31))));
HXLINE( 744)		return p;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_params,return )

Float FlxInputText_obj::set_x(Float X){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_748_set_x)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(X,"X")
HXLINE( 749)		bool _hx_tmp;
HXDLIN( 749)		if (hx::IsNotNull( this->fieldBorderSprite )) {
HXLINE( 749)			_hx_tmp = (this->fieldBorderThickness > (int)0);
            		}
            		else {
HXLINE( 749)			_hx_tmp = false;
            		}
HXDLIN( 749)		if (_hx_tmp) {
HXLINE( 751)			this->fieldBorderSprite->set_x((X - this->fieldBorderThickness));
            		}
HXLINE( 753)		bool _hx_tmp1;
HXDLIN( 753)		if (hx::IsNotNull( this->backgroundSprite )) {
HXLINE( 753)			_hx_tmp1 = this->background;
            		}
            		else {
HXLINE( 753)			_hx_tmp1 = false;
            		}
HXDLIN( 753)		if (_hx_tmp1) {
HXLINE( 755)			this->backgroundSprite->set_x(X);
            		}
HXLINE( 757)		return this->super::set_x(X);
            	}


Float FlxInputText_obj::set_y(Float Y){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_761_set_y)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Y,"Y")
HXLINE( 762)		bool _hx_tmp;
HXDLIN( 762)		if (hx::IsNotNull( this->fieldBorderSprite )) {
HXLINE( 762)			_hx_tmp = (this->fieldBorderThickness > (int)0);
            		}
            		else {
HXLINE( 762)			_hx_tmp = false;
            		}
HXDLIN( 762)		if (_hx_tmp) {
HXLINE( 764)			this->fieldBorderSprite->set_y((Y - this->fieldBorderThickness));
            		}
HXLINE( 766)		bool _hx_tmp1;
HXDLIN( 766)		if (hx::IsNotNull( this->backgroundSprite )) {
HXLINE( 766)			_hx_tmp1 = this->background;
            		}
            		else {
HXLINE( 766)			_hx_tmp1 = false;
            		}
HXDLIN( 766)		if (_hx_tmp1) {
HXLINE( 768)			this->backgroundSprite->set_y(Y);
            		}
HXLINE( 770)		return this->super::set_y(Y);
            	}


bool FlxInputText_obj::set_hasFocus(bool newFocus){
            	HX_GC_STACKFRAME(&_hx_pos_75fddae7e64ce41a_774_set_hasFocus)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(newFocus,"newFocus")
HXLINE( 775)		if (newFocus) {
HXLINE( 777)			if ((this->hasFocus != newFocus)) {
HXLINE( 779)				this->_caretTimer =  ::flixel::util::FlxTimer_obj::__alloc( HX_CTX ,null())->start(((Float)0.5),this->toggleCaret_dyn(),(int)0);
HXLINE( 780)				this->caret->set_visible(true);
HXLINE( 781)				this->set_caretIndex(this->text.length);
            			}
            		}
            		else {
HXLINE( 787)			this->caret->set_visible(false);
HXLINE( 788)			if (hx::IsNotNull( this->_caretTimer )) {
HXLINE( 790)				this->_caretTimer->cancel();
            			}
            		}
HXLINE( 794)		if ((newFocus != this->hasFocus)) {
HXLINE( 796)			this->calcFrame(null());
            		}
HXLINE( 798)		return (this->hasFocus = newFocus);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_hasFocus,return )

::String FlxInputText_obj::getAlignStr(){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_801_getAlignStr)
            	HX_STACK_THIS(this)
HXLINE( 802)		HX_VARI( ::String,alignStr) = HX_("left",07,08,b0,47);
HXLINE( 803)		bool _hx_tmp;
HXDLIN( 803)		if (hx::IsNotNull( this->_defaultFormat )) {
HXLINE( 803)			_hx_tmp = hx::IsNotNull( this->_defaultFormat->align );
            		}
            		else {
HXLINE( 803)			_hx_tmp = false;
            		}
HXDLIN( 803)		if (_hx_tmp) {
HXLINE( 804)			alignStr = ::flixel::text::_FlxText::FlxTextAlign_Impl__obj::fromOpenFL(this->_defaultFormat->align);
            		}
HXLINE( 806)		return alignStr;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxInputText_obj,getAlignStr,return )

int FlxInputText_obj::set_caretIndex(int newCaretIndex){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_810_set_caretIndex)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(newCaretIndex,"newCaretIndex")
HXLINE( 811)		HX_VARI( Float,offx) = (int)0;
HXLINE( 815)		::String _hx_switch_0 = this->getAlignStr();
            		if (  (_hx_switch_0==HX_("center",d5,25,db,05)) ){
HXLINE( 822)			HX_VARI_NAME( Float,offx1,"offx") = (this->textField->get_width() - (int)2);
HXDLIN( 822)			HX_VARI_NAME( Float,offx2,"offx") = ((Float)(offx1 - this->textField->get_textWidth()) / (Float)(int)2);
HXDLIN( 822)			offx = (offx2 + ((Float)this->textField->get_scrollH() / (Float)(int)2));
HXLINE( 824)			if ((offx <= (int)1)) {
HXLINE( 824)				offx = (int)0;
            			}
HXLINE( 820)			goto _hx_goto_31;
            		}
            		if (  (_hx_switch_0==HX_("right",dc,0b,64,e9)) ){
HXLINE( 817)			HX_VARI_NAME( Float,offx3,"offx") = (this->textField->get_width() - (int)2);
HXDLIN( 817)			offx = ((offx3 - this->textField->get_textWidth()) - (int)2);
HXLINE( 818)			if ((offx < (int)0)) {
HXLINE( 818)				offx = (int)0;
            			}
HXLINE( 816)			goto _hx_goto_31;
            		}
            		/* default */{
HXLINE( 826)			offx = (int)0;
            		}
            		_hx_goto_31:;
HXLINE( 829)		this->caretIndex = newCaretIndex;
HXLINE( 832)		if ((this->caretIndex > (this->text.length + (int)1))) {
HXLINE( 834)			this->caretIndex = (int)-1;
            		}
HXLINE( 838)		if ((this->caretIndex != (int)-1)) {
HXLINE( 840)			HX_VARI(  ::openfl::_legacy::geom::Rectangle,boundaries) = null();
HXLINE( 843)			if ((this->caretIndex < this->text.length)) {
HXLINE( 844)				boundaries = this->getCharBoundaries(this->caretIndex);
HXLINE( 845)				if (hx::IsNotNull( boundaries )) {
HXLINE( 847)					this->caret->set_x(((offx + boundaries->get_left()) + this->x));
HXLINE( 848)					this->caret->set_y((boundaries->get_top() + this->y));
            				}
            			}
            			else {
HXLINE( 853)				boundaries = this->getCharBoundaries((this->caretIndex - (int)1));
HXLINE( 854)				if (hx::IsNotNull( boundaries )) {
HXLINE( 856)					this->caret->set_x(((offx + boundaries->get_right()) + this->x));
HXLINE( 857)					this->caret->set_y((boundaries->get_top() + this->y));
            				}
            				else {
HXLINE( 860)					if ((this->text.length == (int)0)) {
HXLINE( 863)						this->caret->set_x(((this->x + offx) + (int)2));
HXLINE( 864)						this->caret->set_y((this->y + (int)2));
            					}
            				}
            			}
            		}
HXLINE( 870)		{
HXLINE( 870)			HX_VARI(  ::flixel::FlxSprite,_g) = this->caret;
HXDLIN( 870)			HX_VARI_NAME( Float,_g1,"_g") = _g->x;
HXDLIN( 870)			_g->set_x((_g1 - this->textField->get_scrollH()));
            		}
HXLINE( 874)		bool _hx_tmp;
HXDLIN( 874)		if ((this->lines == (int)1)) {
HXLINE( 874)			Float _hx_tmp1 = this->caret->x;
HXDLIN( 874)			Float _hx_tmp2 = (_hx_tmp1 + this->caret->get_width());
HXDLIN( 874)			Float _hx_tmp3 = this->x;
HXDLIN( 874)			_hx_tmp = (_hx_tmp2 > (_hx_tmp3 + this->get_width()));
            		}
            		else {
HXLINE( 874)			_hx_tmp = false;
            		}
HXDLIN( 874)		if (_hx_tmp) {
HXLINE( 876)			 ::flixel::FlxSprite _hx_tmp4 = this->caret;
HXDLIN( 876)			Float _hx_tmp5 = this->x;
HXDLIN( 876)			_hx_tmp4->set_x(((_hx_tmp5 + this->get_width()) - (int)2));
            		}
HXLINE( 879)		return this->caretIndex;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_caretIndex,return )

int FlxInputText_obj::set_forceCase(int Value){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_883_set_forceCase)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Value,"Value")
HXLINE( 884)		this->forceCase = Value;
HXLINE( 885)		this->set_text(this->filter(this->text));
HXLINE( 886)		return this->forceCase;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_forceCase,return )

int FlxInputText_obj::set_size(int Value){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_890_set_size)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Value,"Value")
HXLINE( 891)		this->super::set_size(Value);
HXLINE( 892)		 ::flixel::FlxSprite _hx_tmp = this->caret;
HXDLIN( 892)		_hx_tmp->makeGraphic((int)1,::Std_obj::_hx_int((::Std_obj::_hx_int(this->_defaultFormat->size) + (int)2)),null(),null(),null());
HXLINE( 893)		return Value;
            	}


int FlxInputText_obj::set_maxLength(int Value){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_897_set_maxLength)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Value,"Value")
HXLINE( 898)		this->maxLength = Value;
HXLINE( 899)		if ((this->text.length > this->maxLength)) {
HXLINE( 901)			this->set_text(this->text.substring((int)0,this->maxLength));
            		}
HXLINE( 903)		return this->maxLength;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_maxLength,return )

int FlxInputText_obj::set_lines(int Value){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_907_set_lines)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Value,"Value")
HXLINE( 908)		if ((Value == (int)0)) {
HXLINE( 908)			return (int)0;
            		}
HXLINE( 910)		if ((Value > (int)1)) {
HXLINE( 911)			this->textField->set_wordWrap(true);
HXLINE( 912)			this->textField->set_multiline(true);
            		}
            		else {
HXLINE( 915)			this->textField->set_wordWrap(false);
HXLINE( 916)			this->textField->set_multiline(false);
            		}
HXLINE( 919)		this->lines = Value;
HXLINE( 920)		this->calcFrame(null());
HXLINE( 921)		return this->lines;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_lines,return )

bool FlxInputText_obj::get_passwordMode(){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_926_get_passwordMode)
            	HX_STACK_THIS(this)
HXLINE( 926)		return this->textField->get_displayAsPassword();
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxInputText_obj,get_passwordMode,return )

bool FlxInputText_obj::set_passwordMode(bool value){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_930_set_passwordMode)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 931)		this->textField->set_displayAsPassword(value);
HXLINE( 932)		this->calcFrame(null());
HXLINE( 933)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_passwordMode,return )

int FlxInputText_obj::set_filterMode(int Value){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_937_set_filterMode)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Value,"Value")
HXLINE( 938)		this->filterMode = Value;
HXLINE( 939)		this->set_text(this->filter(this->text));
HXLINE( 940)		return this->filterMode;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_filterMode,return )

int FlxInputText_obj::set_fieldBorderColor(int Value){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_944_set_fieldBorderColor)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Value,"Value")
HXLINE( 945)		this->fieldBorderColor = Value;
HXLINE( 946)		this->calcFrame(null());
HXLINE( 947)		return this->fieldBorderColor;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_fieldBorderColor,return )

int FlxInputText_obj::set_fieldBorderThickness(int Value){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_951_set_fieldBorderThickness)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Value,"Value")
HXLINE( 952)		this->fieldBorderThickness = Value;
HXLINE( 953)		this->calcFrame(null());
HXLINE( 954)		return this->fieldBorderThickness;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_fieldBorderThickness,return )

int FlxInputText_obj::set_backgroundColor(int Value){
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_958_set_backgroundColor)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Value,"Value")
HXLINE( 959)		this->backgroundColor = Value;
HXLINE( 960)		this->calcFrame(null());
HXLINE( 961)		return this->backgroundColor;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxInputText_obj,set_backgroundColor,return )

int FlxInputText_obj::NO_FILTER;

int FlxInputText_obj::ONLY_ALPHA;

int FlxInputText_obj::ONLY_NUMERIC;

int FlxInputText_obj::ONLY_ALPHANUMERIC;

int FlxInputText_obj::CUSTOM_FILTER;

int FlxInputText_obj::ALL_CASES;

int FlxInputText_obj::UPPER_CASE;

int FlxInputText_obj::LOWER_CASE;

::String FlxInputText_obj::BACKSPACE_ACTION;

::String FlxInputText_obj::DELETE_ACTION;

::String FlxInputText_obj::ENTER_ACTION;

::String FlxInputText_obj::INPUT_ACTION;


hx::ObjectPtr< FlxInputText_obj > FlxInputText_obj::__new(hx::Null< Float >  __o_X,hx::Null< Float >  __o_Y,hx::Null< int >  __o_Width,::String Text,hx::Null< int >  __o_size,hx::Null< int >  __o_TextColor,hx::Null< int >  __o_BackgroundColor,hx::Null< bool >  __o_EmbeddedFont) {
	hx::ObjectPtr< FlxInputText_obj > __this = new FlxInputText_obj();
	__this->__construct(__o_X,__o_Y,__o_Width,Text,__o_size,__o_TextColor,__o_BackgroundColor,__o_EmbeddedFont);
	return __this;
}

hx::ObjectPtr< FlxInputText_obj > FlxInputText_obj::__alloc(hx::Ctx *_hx_ctx,hx::Null< Float >  __o_X,hx::Null< Float >  __o_Y,hx::Null< int >  __o_Width,::String Text,hx::Null< int >  __o_size,hx::Null< int >  __o_TextColor,hx::Null< int >  __o_BackgroundColor,hx::Null< bool >  __o_EmbeddedFont) {
	FlxInputText_obj *__this = (FlxInputText_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(FlxInputText_obj), true, "flixel.addons.ui.FlxInputText"));
	*(void **)__this = FlxInputText_obj::_hx_vtable;
	__this->__construct(__o_X,__o_Y,__o_Width,Text,__o_size,__o_TextColor,__o_BackgroundColor,__o_EmbeddedFont);
	return __this;
}

FlxInputText_obj::FlxInputText_obj()
{
}

void FlxInputText_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxInputText);
	HX_MARK_MEMBER_NAME(customFilterPattern,"customFilterPattern");
	HX_MARK_MEMBER_NAME(callback,"callback");
	HX_MARK_MEMBER_NAME(background,"background");
	HX_MARK_MEMBER_NAME(caretColor,"caretColor");
	HX_MARK_MEMBER_NAME(caretWidth,"caretWidth");
	HX_MARK_MEMBER_NAME(params,"params");
	HX_MARK_MEMBER_NAME(hasFocus,"hasFocus");
	HX_MARK_MEMBER_NAME(caretIndex,"caretIndex");
	HX_MARK_MEMBER_NAME(forceCase,"forceCase");
	HX_MARK_MEMBER_NAME(maxLength,"maxLength");
	HX_MARK_MEMBER_NAME(lines,"lines");
	HX_MARK_MEMBER_NAME(filterMode,"filterMode");
	HX_MARK_MEMBER_NAME(fieldBorderColor,"fieldBorderColor");
	HX_MARK_MEMBER_NAME(fieldBorderThickness,"fieldBorderThickness");
	HX_MARK_MEMBER_NAME(backgroundColor,"backgroundColor");
	HX_MARK_MEMBER_NAME(backgroundSprite,"backgroundSprite");
	HX_MARK_MEMBER_NAME(_caretTimer,"_caretTimer");
	HX_MARK_MEMBER_NAME(caret,"caret");
	HX_MARK_MEMBER_NAME(fieldBorderSprite,"fieldBorderSprite");
	HX_MARK_MEMBER_NAME(_scrollBoundIndeces,"_scrollBoundIndeces");
	HX_MARK_MEMBER_NAME(_charBoundaries,"_charBoundaries");
	HX_MARK_MEMBER_NAME(lastScroll,"lastScroll");
	 ::flixel::text::FlxText_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxInputText_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(customFilterPattern,"customFilterPattern");
	HX_VISIT_MEMBER_NAME(callback,"callback");
	HX_VISIT_MEMBER_NAME(background,"background");
	HX_VISIT_MEMBER_NAME(caretColor,"caretColor");
	HX_VISIT_MEMBER_NAME(caretWidth,"caretWidth");
	HX_VISIT_MEMBER_NAME(params,"params");
	HX_VISIT_MEMBER_NAME(hasFocus,"hasFocus");
	HX_VISIT_MEMBER_NAME(caretIndex,"caretIndex");
	HX_VISIT_MEMBER_NAME(forceCase,"forceCase");
	HX_VISIT_MEMBER_NAME(maxLength,"maxLength");
	HX_VISIT_MEMBER_NAME(lines,"lines");
	HX_VISIT_MEMBER_NAME(filterMode,"filterMode");
	HX_VISIT_MEMBER_NAME(fieldBorderColor,"fieldBorderColor");
	HX_VISIT_MEMBER_NAME(fieldBorderThickness,"fieldBorderThickness");
	HX_VISIT_MEMBER_NAME(backgroundColor,"backgroundColor");
	HX_VISIT_MEMBER_NAME(backgroundSprite,"backgroundSprite");
	HX_VISIT_MEMBER_NAME(_caretTimer,"_caretTimer");
	HX_VISIT_MEMBER_NAME(caret,"caret");
	HX_VISIT_MEMBER_NAME(fieldBorderSprite,"fieldBorderSprite");
	HX_VISIT_MEMBER_NAME(_scrollBoundIndeces,"_scrollBoundIndeces");
	HX_VISIT_MEMBER_NAME(_charBoundaries,"_charBoundaries");
	HX_VISIT_MEMBER_NAME(lastScroll,"lastScroll");
	 ::flixel::text::FlxText_obj::__Visit(HX_VISIT_ARG);
}

hx::Val FlxInputText_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn()); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"lines") ) { return hx::Val( lines); }
		if (HX_FIELD_EQ(inName,"caret") ) { return hx::Val( caret); }
		if (HX_FIELD_EQ(inName,"set_x") ) { return hx::Val( set_x_dyn()); }
		if (HX_FIELD_EQ(inName,"set_y") ) { return hx::Val( set_y_dyn()); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"params") ) { return hx::Val( params); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn()); }
		if (HX_FIELD_EQ(inName,"filter") ) { return hx::Val( filter_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"callback") ) { return hx::Val( callback); }
		if (HX_FIELD_EQ(inName,"hasFocus") ) { return hx::Val( hasFocus); }
		if (HX_FIELD_EQ(inName,"onChange") ) { return hx::Val( onChange_dyn()); }
		if (HX_FIELD_EQ(inName,"set_text") ) { return hx::Val( set_text_dyn()); }
		if (HX_FIELD_EQ(inName,"set_size") ) { return hx::Val( set_size_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"forceCase") ) { return hx::Val( forceCase); }
		if (HX_FIELD_EQ(inName,"maxLength") ) { return hx::Val( maxLength); }
		if (HX_FIELD_EQ(inName,"onKeyDown") ) { return hx::Val( onKeyDown_dyn()); }
		if (HX_FIELD_EQ(inName,"calcFrame") ) { return hx::Val( calcFrame_dyn()); }
		if (HX_FIELD_EQ(inName,"set_lines") ) { return hx::Val( set_lines_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"background") ) { return hx::Val( background); }
		if (HX_FIELD_EQ(inName,"caretColor") ) { return hx::Val( caretColor); }
		if (HX_FIELD_EQ(inName,"caretWidth") ) { return hx::Val( caretWidth); }
		if (HX_FIELD_EQ(inName,"caretIndex") ) { return hx::Val( caretIndex); }
		if (HX_FIELD_EQ(inName,"filterMode") ) { return hx::Val( filterMode); }
		if (HX_FIELD_EQ(inName,"lastScroll") ) { return hx::Val( lastScroll); }
		if (HX_FIELD_EQ(inName,"drawSprite") ) { return hx::Val( drawSprite_dyn()); }
		if (HX_FIELD_EQ(inName,"set_params") ) { return hx::Val( set_params_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_caretTimer") ) { return hx::Val( _caretTimer); }
		if (HX_FIELD_EQ(inName,"toggleCaret") ) { return hx::Val( toggleCaret_dyn()); }
		if (HX_FIELD_EQ(inName,"getAlignStr") ) { return hx::Val( getAlignStr_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"passwordMode") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_passwordMode()); }
		if (HX_FIELD_EQ(inName,"set_hasFocus") ) { return hx::Val( set_hasFocus_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getCaretIndex") ) { return hx::Val( getCaretIndex_dyn()); }
		if (HX_FIELD_EQ(inName,"set_forceCase") ) { return hx::Val( set_forceCase_dyn()); }
		if (HX_FIELD_EQ(inName,"set_maxLength") ) { return hx::Val( set_maxLength_dyn()); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"set_caretColor") ) { return hx::Val( set_caretColor_dyn()); }
		if (HX_FIELD_EQ(inName,"set_caretWidth") ) { return hx::Val( set_caretWidth_dyn()); }
		if (HX_FIELD_EQ(inName,"onSetTextCheck") ) { return hx::Val( onSetTextCheck_dyn()); }
		if (HX_FIELD_EQ(inName,"set_caretIndex") ) { return hx::Val( set_caretIndex_dyn()); }
		if (HX_FIELD_EQ(inName,"set_filterMode") ) { return hx::Val( set_filterMode_dyn()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"backgroundColor") ) { return hx::Val( backgroundColor); }
		if (HX_FIELD_EQ(inName,"_charBoundaries") ) { return hx::Val( _charBoundaries); }
		if (HX_FIELD_EQ(inName,"insertSubstring") ) { return hx::Val( insertSubstring_dyn()); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"fieldBorderColor") ) { return hx::Val( fieldBorderColor); }
		if (HX_FIELD_EQ(inName,"backgroundSprite") ) { return hx::Val( backgroundSprite); }
		if (HX_FIELD_EQ(inName,"get_passwordMode") ) { return hx::Val( get_passwordMode_dyn()); }
		if (HX_FIELD_EQ(inName,"set_passwordMode") ) { return hx::Val( set_passwordMode_dyn()); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"fieldBorderSprite") ) { return hx::Val( fieldBorderSprite); }
		if (HX_FIELD_EQ(inName,"getCharBoundaries") ) { return hx::Val( getCharBoundaries_dyn()); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"customFilterPattern") ) { return hx::Val( customFilterPattern); }
		if (HX_FIELD_EQ(inName,"_scrollBoundIndeces") ) { return hx::Val( _scrollBoundIndeces); }
		if (HX_FIELD_EQ(inName,"getCharIndexAtPoint") ) { return hx::Val( getCharIndexAtPoint_dyn()); }
		if (HX_FIELD_EQ(inName,"set_backgroundColor") ) { return hx::Val( set_backgroundColor_dyn()); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"fieldBorderThickness") ) { return hx::Val( fieldBorderThickness); }
		if (HX_FIELD_EQ(inName,"set_fieldBorderColor") ) { return hx::Val( set_fieldBorderColor_dyn()); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"prepareCharBoundaries") ) { return hx::Val( prepareCharBoundaries_dyn()); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"set_customFilterPattern") ) { return hx::Val( set_customFilterPattern_dyn()); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"set_fieldBorderThickness") ) { return hx::Val( set_fieldBorderThickness_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val FlxInputText_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"lines") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_lines(inValue) );lines=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"caret") ) { caret=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"params") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_params(inValue) );params=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"callback") ) { callback=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"hasFocus") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_hasFocus(inValue) );hasFocus=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"forceCase") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_forceCase(inValue) );forceCase=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxLength") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_maxLength(inValue) );maxLength=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"background") ) { background=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"caretColor") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_caretColor(inValue) );caretColor=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"caretWidth") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_caretWidth(inValue) );caretWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"caretIndex") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_caretIndex(inValue) );caretIndex=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"filterMode") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_filterMode(inValue) );filterMode=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastScroll") ) { lastScroll=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_caretTimer") ) { _caretTimer=inValue.Cast<  ::flixel::util::FlxTimer >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"passwordMode") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_passwordMode(inValue) ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"backgroundColor") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_backgroundColor(inValue) );backgroundColor=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_charBoundaries") ) { _charBoundaries=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"fieldBorderColor") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_fieldBorderColor(inValue) );fieldBorderColor=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"backgroundSprite") ) { backgroundSprite=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"fieldBorderSprite") ) { fieldBorderSprite=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"customFilterPattern") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_customFilterPattern(inValue) );customFilterPattern=inValue.Cast<  ::EReg >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_scrollBoundIndeces") ) { _scrollBoundIndeces=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"fieldBorderThickness") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_fieldBorderThickness(inValue) );fieldBorderThickness=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxInputText_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("customFilterPattern","\x07","\x03","\x33","\x08"));
	outFields->push(HX_HCSTRING("background","\xee","\x93","\x1d","\x26"));
	outFields->push(HX_HCSTRING("caretColor","\xe0","\x8c","\xa3","\x69"));
	outFields->push(HX_HCSTRING("caretWidth","\x83","\xd1","\xa9","\xe9"));
	outFields->push(HX_HCSTRING("params","\x46","\xfb","\x7a","\xed"));
	outFields->push(HX_HCSTRING("passwordMode","\x1e","\x4c","\x29","\xb6"));
	outFields->push(HX_HCSTRING("hasFocus","\x1e","\xaa","\xe1","\x90"));
	outFields->push(HX_HCSTRING("caretIndex","\x8f","\xb6","\x5b","\xdd"));
	outFields->push(HX_HCSTRING("forceCase","\x3b","\xce","\xfe","\x46"));
	outFields->push(HX_HCSTRING("maxLength","\xaa","\xa6","\x92","\xce"));
	outFields->push(HX_HCSTRING("lines","\xff","\xdd","\x01","\x75"));
	outFields->push(HX_HCSTRING("filterMode","\x3b","\x5b","\xa5","\x54"));
	outFields->push(HX_HCSTRING("fieldBorderColor","\x3d","\x66","\xca","\x1d"));
	outFields->push(HX_HCSTRING("fieldBorderThickness","\x4e","\x5b","\x39","\x33"));
	outFields->push(HX_HCSTRING("backgroundColor","\x95","\x4e","\x47","\x0d"));
	outFields->push(HX_HCSTRING("backgroundSprite","\x93","\x8a","\x2c","\x8e"));
	outFields->push(HX_HCSTRING("_caretTimer","\x61","\xa8","\x06","\x02"));
	outFields->push(HX_HCSTRING("caret","\x83","\xf9","\x1f","\x41"));
	outFields->push(HX_HCSTRING("fieldBorderSprite","\xeb","\x25","\x5e","\xf0"));
	outFields->push(HX_HCSTRING("_scrollBoundIndeces","\xd9","\x8f","\x2d","\x01"));
	outFields->push(HX_HCSTRING("_charBoundaries","\xdd","\x1e","\x8e","\x62"));
	outFields->push(HX_HCSTRING("lastScroll","\x03","\xbb","\x3f","\x12"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo FlxInputText_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::EReg*/ ,(int)offsetof(FlxInputText_obj,customFilterPattern),HX_HCSTRING("customFilterPattern","\x07","\x03","\x33","\x08")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(FlxInputText_obj,callback),HX_HCSTRING("callback","\xc5","\x99","\x06","\x7f")},
	{hx::fsBool,(int)offsetof(FlxInputText_obj,background),HX_HCSTRING("background","\xee","\x93","\x1d","\x26")},
	{hx::fsInt,(int)offsetof(FlxInputText_obj,caretColor),HX_HCSTRING("caretColor","\xe0","\x8c","\xa3","\x69")},
	{hx::fsInt,(int)offsetof(FlxInputText_obj,caretWidth),HX_HCSTRING("caretWidth","\x83","\xd1","\xa9","\xe9")},
	{hx::fsObject /*cpp::ArrayBase*/ ,(int)offsetof(FlxInputText_obj,params),HX_HCSTRING("params","\x46","\xfb","\x7a","\xed")},
	{hx::fsBool,(int)offsetof(FlxInputText_obj,hasFocus),HX_HCSTRING("hasFocus","\x1e","\xaa","\xe1","\x90")},
	{hx::fsInt,(int)offsetof(FlxInputText_obj,caretIndex),HX_HCSTRING("caretIndex","\x8f","\xb6","\x5b","\xdd")},
	{hx::fsInt,(int)offsetof(FlxInputText_obj,forceCase),HX_HCSTRING("forceCase","\x3b","\xce","\xfe","\x46")},
	{hx::fsInt,(int)offsetof(FlxInputText_obj,maxLength),HX_HCSTRING("maxLength","\xaa","\xa6","\x92","\xce")},
	{hx::fsInt,(int)offsetof(FlxInputText_obj,lines),HX_HCSTRING("lines","\xff","\xdd","\x01","\x75")},
	{hx::fsInt,(int)offsetof(FlxInputText_obj,filterMode),HX_HCSTRING("filterMode","\x3b","\x5b","\xa5","\x54")},
	{hx::fsInt,(int)offsetof(FlxInputText_obj,fieldBorderColor),HX_HCSTRING("fieldBorderColor","\x3d","\x66","\xca","\x1d")},
	{hx::fsInt,(int)offsetof(FlxInputText_obj,fieldBorderThickness),HX_HCSTRING("fieldBorderThickness","\x4e","\x5b","\x39","\x33")},
	{hx::fsInt,(int)offsetof(FlxInputText_obj,backgroundColor),HX_HCSTRING("backgroundColor","\x95","\x4e","\x47","\x0d")},
	{hx::fsObject /*::flixel::FlxSprite*/ ,(int)offsetof(FlxInputText_obj,backgroundSprite),HX_HCSTRING("backgroundSprite","\x93","\x8a","\x2c","\x8e")},
	{hx::fsObject /*::flixel::util::FlxTimer*/ ,(int)offsetof(FlxInputText_obj,_caretTimer),HX_HCSTRING("_caretTimer","\x61","\xa8","\x06","\x02")},
	{hx::fsObject /*::flixel::FlxSprite*/ ,(int)offsetof(FlxInputText_obj,caret),HX_HCSTRING("caret","\x83","\xf9","\x1f","\x41")},
	{hx::fsObject /*::flixel::FlxSprite*/ ,(int)offsetof(FlxInputText_obj,fieldBorderSprite),HX_HCSTRING("fieldBorderSprite","\xeb","\x25","\x5e","\xf0")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(FlxInputText_obj,_scrollBoundIndeces),HX_HCSTRING("_scrollBoundIndeces","\xd9","\x8f","\x2d","\x01")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(FlxInputText_obj,_charBoundaries),HX_HCSTRING("_charBoundaries","\xdd","\x1e","\x8e","\x62")},
	{hx::fsInt,(int)offsetof(FlxInputText_obj,lastScroll),HX_HCSTRING("lastScroll","\x03","\xbb","\x3f","\x12")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo FlxInputText_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &FlxInputText_obj::NO_FILTER,HX_HCSTRING("NO_FILTER","\x36","\x13","\x4e","\x92")},
	{hx::fsInt,(void *) &FlxInputText_obj::ONLY_ALPHA,HX_HCSTRING("ONLY_ALPHA","\xeb","\x4c","\xe5","\xa7")},
	{hx::fsInt,(void *) &FlxInputText_obj::ONLY_NUMERIC,HX_HCSTRING("ONLY_NUMERIC","\x9a","\xa9","\x2d","\x5f")},
	{hx::fsInt,(void *) &FlxInputText_obj::ONLY_ALPHANUMERIC,HX_HCSTRING("ONLY_ALPHANUMERIC","\x22","\xad","\x7f","\xf5")},
	{hx::fsInt,(void *) &FlxInputText_obj::CUSTOM_FILTER,HX_HCSTRING("CUSTOM_FILTER","\xc6","\xf1","\x56","\xe9")},
	{hx::fsInt,(void *) &FlxInputText_obj::ALL_CASES,HX_HCSTRING("ALL_CASES","\xa5","\x06","\x9b","\x9d")},
	{hx::fsInt,(void *) &FlxInputText_obj::UPPER_CASE,HX_HCSTRING("UPPER_CASE","\x0d","\xe2","\x06","\x82")},
	{hx::fsInt,(void *) &FlxInputText_obj::LOWER_CASE,HX_HCSTRING("LOWER_CASE","\x0e","\x61","\xd8","\x7c")},
	{hx::fsString,(void *) &FlxInputText_obj::BACKSPACE_ACTION,HX_HCSTRING("BACKSPACE_ACTION","\x16","\x76","\x91","\xd1")},
	{hx::fsString,(void *) &FlxInputText_obj::DELETE_ACTION,HX_HCSTRING("DELETE_ACTION","\x8a","\x38","\xe3","\x2e")},
	{hx::fsString,(void *) &FlxInputText_obj::ENTER_ACTION,HX_HCSTRING("ENTER_ACTION","\x5d","\x63","\x46","\x79")},
	{hx::fsString,(void *) &FlxInputText_obj::INPUT_ACTION,HX_HCSTRING("INPUT_ACTION","\xab","\xae","\x95","\x20")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxInputText_obj_sMemberFields[] = {
	HX_HCSTRING("customFilterPattern","\x07","\x03","\x33","\x08"),
	HX_HCSTRING("set_customFilterPattern","\xaa","\x12","\xea","\x12"),
	HX_HCSTRING("callback","\xc5","\x99","\x06","\x7f"),
	HX_HCSTRING("background","\xee","\x93","\x1d","\x26"),
	HX_HCSTRING("caretColor","\xe0","\x8c","\xa3","\x69"),
	HX_HCSTRING("set_caretColor","\x9d","\xfd","\xb8","\xff"),
	HX_HCSTRING("caretWidth","\x83","\xd1","\xa9","\xe9"),
	HX_HCSTRING("set_caretWidth","\x40","\x42","\xbf","\x7f"),
	HX_HCSTRING("params","\x46","\xfb","\x7a","\xed"),
	HX_HCSTRING("hasFocus","\x1e","\xaa","\xe1","\x90"),
	HX_HCSTRING("caretIndex","\x8f","\xb6","\x5b","\xdd"),
	HX_HCSTRING("forceCase","\x3b","\xce","\xfe","\x46"),
	HX_HCSTRING("maxLength","\xaa","\xa6","\x92","\xce"),
	HX_HCSTRING("lines","\xff","\xdd","\x01","\x75"),
	HX_HCSTRING("filterMode","\x3b","\x5b","\xa5","\x54"),
	HX_HCSTRING("fieldBorderColor","\x3d","\x66","\xca","\x1d"),
	HX_HCSTRING("fieldBorderThickness","\x4e","\x5b","\x39","\x33"),
	HX_HCSTRING("backgroundColor","\x95","\x4e","\x47","\x0d"),
	HX_HCSTRING("backgroundSprite","\x93","\x8a","\x2c","\x8e"),
	HX_HCSTRING("_caretTimer","\x61","\xa8","\x06","\x02"),
	HX_HCSTRING("caret","\x83","\xf9","\x1f","\x41"),
	HX_HCSTRING("fieldBorderSprite","\xeb","\x25","\x5e","\xf0"),
	HX_HCSTRING("_scrollBoundIndeces","\xd9","\x8f","\x2d","\x01"),
	HX_HCSTRING("_charBoundaries","\xdd","\x1e","\x8e","\x62"),
	HX_HCSTRING("lastScroll","\x03","\xbb","\x3f","\x12"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("draw","\x04","\x2c","\x70","\x42"),
	HX_HCSTRING("drawSprite","\x29","\x57","\x59","\x05"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	HX_HCSTRING("onKeyDown","\x42","\x22","\xf2","\x73"),
	HX_HCSTRING("onChange","\xef","\x87","\x1f","\x97"),
	HX_HCSTRING("insertSubstring","\xd8","\xdf","\x31","\x11"),
	HX_HCSTRING("getCaretIndex","\xc5","\x12","\xce","\x39"),
	HX_HCSTRING("getCharBoundaries","\x74","\x85","\xa1","\x8b"),
	HX_HCSTRING("set_text","\xaa","\xe1","\x11","\x7b"),
	HX_HCSTRING("getCharIndexAtPoint","\x17","\xee","\x9c","\xaa"),
	HX_HCSTRING("prepareCharBoundaries","\x25","\xfa","\x4d","\x3a"),
	HX_HCSTRING("onSetTextCheck","\x98","\x48","\xe3","\x2c"),
	HX_HCSTRING("calcFrame","\x58","\x93","\x8c","\xf9"),
	HX_HCSTRING("toggleCaret","\x4f","\xb1","\xe6","\x68"),
	HX_HCSTRING("filter","\xb8","\x1f","\x35","\x85"),
	HX_HCSTRING("set_params","\x83","\x09","\x80","\xe1"),
	HX_HCSTRING("set_x","\x5b","\x9b","\x2f","\x7a"),
	HX_HCSTRING("set_y","\x5c","\x9b","\x2f","\x7a"),
	HX_HCSTRING("set_hasFocus","\x9b","\x81","\xf4","\x5a"),
	HX_HCSTRING("getAlignStr","\xa2","\x95","\xd2","\xef"),
	HX_HCSTRING("set_caretIndex","\x4c","\x27","\x71","\x73"),
	HX_HCSTRING("set_forceCase","\x1e","\x84","\x68","\x4d"),
	HX_HCSTRING("set_size","\xbe","\xb5","\x6b","\x7a"),
	HX_HCSTRING("set_maxLength","\x8d","\x5c","\xfc","\xd4"),
	HX_HCSTRING("set_lines","\x62","\x26","\xfc","\x9b"),
	HX_HCSTRING("get_passwordMode","\xa7","\x38","\xc8","\xba"),
	HX_HCSTRING("set_passwordMode","\x1b","\x26","\x0a","\x11"),
	HX_HCSTRING("set_filterMode","\xf8","\xcb","\xba","\xea"),
	HX_HCSTRING("set_fieldBorderColor","\xba","\x82","\xec","\x08"),
	HX_HCSTRING("set_fieldBorderThickness","\x4b","\xfa","\xaf","\x88"),
	HX_HCSTRING("set_backgroundColor","\xb8","\x10","\xef","\xd4"),
	::String(null()) };

static void FlxInputText_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxInputText_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::NO_FILTER,"NO_FILTER");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::ONLY_ALPHA,"ONLY_ALPHA");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::ONLY_NUMERIC,"ONLY_NUMERIC");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::ONLY_ALPHANUMERIC,"ONLY_ALPHANUMERIC");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::CUSTOM_FILTER,"CUSTOM_FILTER");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::ALL_CASES,"ALL_CASES");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::UPPER_CASE,"UPPER_CASE");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::LOWER_CASE,"LOWER_CASE");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::BACKSPACE_ACTION,"BACKSPACE_ACTION");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::DELETE_ACTION,"DELETE_ACTION");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::ENTER_ACTION,"ENTER_ACTION");
	HX_MARK_MEMBER_NAME(FlxInputText_obj::INPUT_ACTION,"INPUT_ACTION");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxInputText_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::NO_FILTER,"NO_FILTER");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::ONLY_ALPHA,"ONLY_ALPHA");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::ONLY_NUMERIC,"ONLY_NUMERIC");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::ONLY_ALPHANUMERIC,"ONLY_ALPHANUMERIC");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::CUSTOM_FILTER,"CUSTOM_FILTER");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::ALL_CASES,"ALL_CASES");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::UPPER_CASE,"UPPER_CASE");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::LOWER_CASE,"LOWER_CASE");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::BACKSPACE_ACTION,"BACKSPACE_ACTION");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::DELETE_ACTION,"DELETE_ACTION");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::ENTER_ACTION,"ENTER_ACTION");
	HX_VISIT_MEMBER_NAME(FlxInputText_obj::INPUT_ACTION,"INPUT_ACTION");
};

#endif

hx::Class FlxInputText_obj::__mClass;

static ::String FlxInputText_obj_sStaticFields[] = {
	HX_HCSTRING("NO_FILTER","\x36","\x13","\x4e","\x92"),
	HX_HCSTRING("ONLY_ALPHA","\xeb","\x4c","\xe5","\xa7"),
	HX_HCSTRING("ONLY_NUMERIC","\x9a","\xa9","\x2d","\x5f"),
	HX_HCSTRING("ONLY_ALPHANUMERIC","\x22","\xad","\x7f","\xf5"),
	HX_HCSTRING("CUSTOM_FILTER","\xc6","\xf1","\x56","\xe9"),
	HX_HCSTRING("ALL_CASES","\xa5","\x06","\x9b","\x9d"),
	HX_HCSTRING("UPPER_CASE","\x0d","\xe2","\x06","\x82"),
	HX_HCSTRING("LOWER_CASE","\x0e","\x61","\xd8","\x7c"),
	HX_HCSTRING("BACKSPACE_ACTION","\x16","\x76","\x91","\xd1"),
	HX_HCSTRING("DELETE_ACTION","\x8a","\x38","\xe3","\x2e"),
	HX_HCSTRING("ENTER_ACTION","\x5d","\x63","\x46","\x79"),
	HX_HCSTRING("INPUT_ACTION","\xab","\xae","\x95","\x20"),
	::String(null())
};

void FlxInputText_obj::__register()
{
	hx::Object *dummy = new FlxInputText_obj;
	FlxInputText_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.addons.ui.FlxInputText","\xd6","\xdd","\xcc","\xb8");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = FlxInputText_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxInputText_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(FlxInputText_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< FlxInputText_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxInputText_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxInputText_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxInputText_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxInputText_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_31_boot)
HXLINE(  31)		NO_FILTER = (int)0;
            	}
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_32_boot)
HXLINE(  32)		ONLY_ALPHA = (int)1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_33_boot)
HXLINE(  33)		ONLY_NUMERIC = (int)2;
            	}
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_34_boot)
HXLINE(  34)		ONLY_ALPHANUMERIC = (int)3;
            	}
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_35_boot)
HXLINE(  35)		CUSTOM_FILTER = (int)4;
            	}
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_37_boot)
HXLINE(  37)		ALL_CASES = (int)0;
            	}
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_38_boot)
HXLINE(  38)		UPPER_CASE = (int)1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_39_boot)
HXLINE(  39)		LOWER_CASE = (int)2;
            	}
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_41_boot)
HXLINE(  41)		BACKSPACE_ACTION = HX_("backspace",3f,85,ea,ca);
            	}
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_42_boot)
HXLINE(  42)		DELETE_ACTION = HX_("delete",2b,c0,d8,6a);
            	}
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_43_boot)
HXLINE(  43)		ENTER_ACTION = HX_("enter",18,6d,86,70);
            	}
{
            	HX_STACKFRAME(&_hx_pos_75fddae7e64ce41a_44_boot)
HXLINE(  44)		INPUT_ACTION = HX_("input",0a,c4,1d,be);
            	}
}

} // end namespace flixel
} // end namespace addons
} // end namespace ui
