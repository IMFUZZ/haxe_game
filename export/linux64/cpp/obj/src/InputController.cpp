// Generated by Haxe 3.4.0
#include <hxcpp.h>

#ifndef INCLUDED_InputController
#include <InputController.h>
#endif
#ifndef INCLUDED_Shared
#include <Shared.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepad
#include <flixel/input/gamepad/FlxGamepad.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_FlxGamepadMapping
#include <flixel/input/gamepad/mappings/FlxGamepadMapping.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_712c30739789f572_15_new,"InputController","new",0xecdcc518,"InputController.new","InputController.hx",15,0x23806558)
HX_DEFINE_STACK_FRAME(_hx_pos_712c30739789f572_27_addKeyboardEvent,"InputController","addKeyboardEvent",0x4749935a,"InputController.addKeyboardEvent","InputController.hx",27,0x23806558)
HX_DEFINE_STACK_FRAME(_hx_pos_712c30739789f572_31_addMouseEvent,"InputController","addMouseEvent",0x827a0fee,"InputController.addMouseEvent","InputController.hx",31,0x23806558)
HX_DEFINE_STACK_FRAME(_hx_pos_712c30739789f572_35_addGamepadEvent,"InputController","addGamepadEvent",0xe6660432,"InputController.addGamepadEvent","InputController.hx",35,0x23806558)
HX_DEFINE_STACK_FRAME(_hx_pos_712c30739789f572_38_updateControls,"InputController","updateControls",0xf370cfe7,"InputController.updateControls","InputController.hx",38,0x23806558)

void InputController_obj::__construct(::Array< int > flxInputStates){
            	HX_GC_STACKFRAME(&_hx_pos_712c30739789f572_15_new)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(flxInputStates,"flxInputStates")
HXLINE(  16)		this->_keyboardEvents =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  17)		this->_mouseEvents =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  18)		this->_gamepadEvents =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  19)		{
HXLINE(  19)			HX_VARI( int,_g) = (int)0;
HXDLIN(  19)			while((_g < flxInputStates->length)){
HXLINE(  19)				HX_VARI( int,flxInputState) = flxInputStates->__get(_g);
HXDLIN(  19)				_g = (_g + (int)1);
HXLINE(  20)				this->_keyboardEvents->set(flxInputState, ::haxe::ds::StringMap_obj::__alloc( HX_CTX ));
HXLINE(  21)				this->_mouseEvents->set(flxInputState, ::haxe::ds::StringMap_obj::__alloc( HX_CTX ));
HXLINE(  22)				this->_gamepadEvents->set(flxInputState, ::haxe::ds::StringMap_obj::__alloc( HX_CTX ));
            			}
            		}
            	}

Dynamic InputController_obj::__CreateEmpty() { return new InputController_obj; }

void *InputController_obj::_hx_vtable = 0;

Dynamic InputController_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< InputController_obj > _hx_result = new InputController_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool InputController_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x13269926;
}

void InputController_obj::addKeyboardEvent(int state,::String key, ::Dynamic action){
            	HX_STACKFRAME(&_hx_pos_712c30739789f572_27_addKeyboardEvent)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(state,"state")
            	HX_STACK_ARG(key,"key")
            	HX_STACK_ARG(action,"action")
HXLINE(  27)		this->_keyboardEvents->get(state).StaticCast<  ::haxe::ds::StringMap >()->set(key,action);
            	}


HX_DEFINE_DYNAMIC_FUNC3(InputController_obj,addKeyboardEvent,(void))

void InputController_obj::addMouseEvent(int state,::String button, ::Dynamic action){
            	HX_STACKFRAME(&_hx_pos_712c30739789f572_31_addMouseEvent)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(state,"state")
            	HX_STACK_ARG(button,"button")
            	HX_STACK_ARG(action,"action")
HXLINE(  31)		this->_mouseEvents->get(state).StaticCast<  ::haxe::ds::StringMap >()->set(button,action);
            	}


HX_DEFINE_DYNAMIC_FUNC3(InputController_obj,addMouseEvent,(void))

void InputController_obj::addGamepadEvent(int state,::String button, ::Dynamic action){
            	HX_STACKFRAME(&_hx_pos_712c30739789f572_35_addGamepadEvent)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(state,"state")
            	HX_STACK_ARG(button,"button")
            	HX_STACK_ARG(action,"action")
HXLINE(  35)		this->_gamepadEvents->get(state).StaticCast<  ::haxe::ds::StringMap >()->set(button,action);
            	}


HX_DEFINE_DYNAMIC_FUNC3(InputController_obj,addGamepadEvent,(void))

void InputController_obj::updateControls( ::flixel::input::keyboard::FlxKeyboard a_keys, ::flixel::input::mouse::FlxMouse a_mouse, ::flixel::input::gamepad::FlxGamepad a_gamepad){
            	HX_STACKFRAME(&_hx_pos_712c30739789f572_38_updateControls)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(a_keys,"a_keys")
            	HX_STACK_ARG(a_mouse,"a_mouse")
            	HX_STACK_ARG(a_gamepad,"a_gamepad")
HXLINE(  39)		HX_VAR(  ::haxe::ds::StringMap,stateMap);
HXLINE(  41)		{
HXLINE(  41)			HX_VARI(  ::Dynamic,flxInputState) = this->_keyboardEvents->keys();
HXDLIN(  41)			while(( (bool)(flxInputState->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  41)				HX_VARI_NAME( int,flxInputState1,"flxInputState") = ( (int)(flxInputState->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE(  42)				stateMap = this->_keyboardEvents->get(flxInputState1).StaticCast<  ::haxe::ds::StringMap >();
HXLINE(  43)				{
HXLINE(  43)					HX_VARI(  ::Dynamic,key) = stateMap->keys();
HXDLIN(  43)					while(( (bool)(key->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  43)						HX_VARI_NAME( ::String,key1,"key") = ( (::String)(key->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE(  44)						if (a_keys->checkStatus(::Shared_obj::supportedKeys->get(key1),flxInputState1)) {
HXLINE(  45)							stateMap->get(key1)(null());
            						}
            					}
            				}
            			}
            		}
HXLINE(  49)		{
HXLINE(  49)			HX_VARI_NAME(  ::Dynamic,flxInputState2,"flxInputState") = this->_mouseEvents->keys();
HXDLIN(  49)			while(( (bool)(flxInputState2->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  49)				HX_VARI_NAME( int,flxInputState3,"flxInputState") = ( (int)(flxInputState2->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE(  50)				stateMap = this->_mouseEvents->get(flxInputState3).StaticCast<  ::haxe::ds::StringMap >();
HXLINE(  51)				{
HXLINE(  51)					HX_VARI_NAME(  ::Dynamic,key2,"key") = stateMap->keys();
HXDLIN(  51)					while(( (bool)(key2->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  51)						HX_VARI_NAME( ::String,key3,"key") = ( (::String)(key2->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE(  52)						::String _hx_switch_0 = key3;
            						if (  (_hx_switch_0==HX_("LEFTCLICK",c1,6a,69,c5)) ){
HXLINE(  54)							switch((int)(flxInputState3)){
            								case (int)-1: {
HXLINE(  66)									if ((a_mouse->_leftButton->current == (int)-1)) {
HXLINE(  67)										stateMap->get(key3)(null());
            									}
HXLINE(  69)									goto _hx_goto_8;
            								}
            								break;
            								case (int)1: {
HXLINE(  56)									HX_VARI(  ::flixel::input::mouse::FlxMouseButton,_this) = a_mouse->_leftButton;
HXDLIN(  56)									bool _hx_tmp;
HXDLIN(  56)									if ((_this->current != (int)1)) {
HXLINE(  56)										_hx_tmp = (_this->current == (int)2);
            									}
            									else {
HXLINE(  56)										_hx_tmp = true;
            									}
HXDLIN(  56)									if (_hx_tmp) {
HXLINE(  57)										stateMap->get(key3)(null());
            									}
HXLINE(  59)									goto _hx_goto_8;
            								}
            								break;
            								case (int)2: {
HXLINE(  61)									if ((a_mouse->_leftButton->current == (int)2)) {
HXLINE(  62)										stateMap->get(key3)(null());
            									}
HXLINE(  64)									goto _hx_goto_8;
            								}
            								break;
            							}
HXLINE(  71)							goto _hx_goto_8;
HXLINE(  53)							goto _hx_goto_9;
            						}
            						if (  (_hx_switch_0==HX_("MIDDLECLICK",b3,80,f4,86)) ){
HXLINE(  92)							switch((int)(flxInputState3)){
            								case (int)-1: {
HXLINE( 104)									if ((a_mouse->_middleButton->current == (int)-1)) {
HXLINE( 105)										stateMap->get(key3)(null());
            									}
HXLINE( 107)									goto _hx_goto_8;
            								}
            								break;
            								case (int)1: {
HXLINE(  94)									HX_VARI_NAME(  ::flixel::input::mouse::FlxMouseButton,_this1,"_this") = a_mouse->_middleButton;
HXDLIN(  94)									bool _hx_tmp1;
HXDLIN(  94)									if ((_this1->current != (int)1)) {
HXLINE(  94)										_hx_tmp1 = (_this1->current == (int)2);
            									}
            									else {
HXLINE(  94)										_hx_tmp1 = true;
            									}
HXDLIN(  94)									if (_hx_tmp1) {
HXLINE(  95)										stateMap->get(key3)(null());
            									}
HXLINE(  97)									goto _hx_goto_8;
            								}
            								break;
            								case (int)2: {
HXLINE(  99)									if ((a_mouse->_middleButton->current == (int)2)) {
HXLINE( 100)										stateMap->get(key3)(null());
            									}
HXLINE( 102)									goto _hx_goto_8;
            								}
            								break;
            							}
HXLINE( 109)							goto _hx_goto_8;
HXLINE(  91)							goto _hx_goto_9;
            						}
            						if (  (_hx_switch_0==HX_("RIGHTCLICK",ec,66,ff,a9)) ){
HXLINE(  73)							switch((int)(flxInputState3)){
            								case (int)-1: {
HXLINE(  85)									if ((a_mouse->_rightButton->current == (int)-1)) {
HXLINE(  86)										stateMap->get(key3)(null());
            									}
HXLINE(  88)									goto _hx_goto_8;
            								}
            								break;
            								case (int)1: {
HXLINE(  75)									HX_VARI_NAME(  ::flixel::input::mouse::FlxMouseButton,_this2,"_this") = a_mouse->_rightButton;
HXDLIN(  75)									bool _hx_tmp2;
HXDLIN(  75)									if ((_this2->current != (int)1)) {
HXLINE(  75)										_hx_tmp2 = (_this2->current == (int)2);
            									}
            									else {
HXLINE(  75)										_hx_tmp2 = true;
            									}
HXDLIN(  75)									if (_hx_tmp2) {
HXLINE(  76)										stateMap->get(key3)(null());
            									}
HXLINE(  78)									goto _hx_goto_8;
            								}
            								break;
            								case (int)2: {
HXLINE(  80)									if ((a_mouse->_rightButton->current == (int)2)) {
HXLINE(  81)										stateMap->get(key3)(null());
            									}
HXLINE(  83)									goto _hx_goto_8;
            								}
            								break;
            							}
HXLINE(  90)							goto _hx_goto_8;
HXLINE(  72)							goto _hx_goto_9;
            						}
            						_hx_goto_9:;
            					}
            					_hx_goto_8:;
            				}
            			}
            		}
HXLINE( 113)		{
HXLINE( 113)			HX_VARI_NAME(  ::Dynamic,flxInputState4,"flxInputState") = this->_gamepadEvents->keys();
HXDLIN( 113)			while(( (bool)(flxInputState4->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 113)				HX_VARI_NAME( int,flxInputState5,"flxInputState") = ( (int)(flxInputState4->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 114)				stateMap = this->_gamepadEvents->get(flxInputState5).StaticCast<  ::haxe::ds::StringMap >();
HXLINE( 115)				{
HXLINE( 115)					HX_VARI_NAME(  ::Dynamic,key4,"key") = stateMap->keys();
HXDLIN( 115)					while(( (bool)(key4->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 115)						HX_VARI_NAME( ::String,key5,"key") = ( (::String)(key4->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 116)						int ID = ( (int)(::Shared_obj::supportedKeys->get(key5)) );
HXDLIN( 116)						if (a_gamepad->checkStatusRaw(a_gamepad->mapping->getRawID(ID),flxInputState5)) {
HXLINE( 117)							stateMap->get(key5)(null());
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(InputController_obj,updateControls,(void))


hx::ObjectPtr< InputController_obj > InputController_obj::__new(::Array< int > flxInputStates) {
	hx::ObjectPtr< InputController_obj > __this = new InputController_obj();
	__this->__construct(flxInputStates);
	return __this;
}

hx::ObjectPtr< InputController_obj > InputController_obj::__alloc(hx::Ctx *_hx_ctx,::Array< int > flxInputStates) {
	InputController_obj *__this = (InputController_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(InputController_obj), true, "InputController"));
	*(void **)__this = InputController_obj::_hx_vtable;
	__this->__construct(flxInputStates);
	return __this;
}

InputController_obj::InputController_obj()
{
}

void InputController_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(InputController);
	HX_MARK_MEMBER_NAME(_keyboardEvents,"_keyboardEvents");
	HX_MARK_MEMBER_NAME(_mouseEvents,"_mouseEvents");
	HX_MARK_MEMBER_NAME(_gamepadEvents,"_gamepadEvents");
	HX_MARK_END_CLASS();
}

void InputController_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_keyboardEvents,"_keyboardEvents");
	HX_VISIT_MEMBER_NAME(_mouseEvents,"_mouseEvents");
	HX_VISIT_MEMBER_NAME(_gamepadEvents,"_gamepadEvents");
}

hx::Val InputController_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"_mouseEvents") ) { return hx::Val( _mouseEvents); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"addMouseEvent") ) { return hx::Val( addMouseEvent_dyn()); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_gamepadEvents") ) { return hx::Val( _gamepadEvents); }
		if (HX_FIELD_EQ(inName,"updateControls") ) { return hx::Val( updateControls_dyn()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_keyboardEvents") ) { return hx::Val( _keyboardEvents); }
		if (HX_FIELD_EQ(inName,"addGamepadEvent") ) { return hx::Val( addGamepadEvent_dyn()); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"addKeyboardEvent") ) { return hx::Val( addKeyboardEvent_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val InputController_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"_mouseEvents") ) { _mouseEvents=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_gamepadEvents") ) { _gamepadEvents=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_keyboardEvents") ) { _keyboardEvents=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void InputController_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("_keyboardEvents","\xbf","\x3f","\xfe","\x64"));
	outFields->push(HX_HCSTRING("_mouseEvents","\x1f","\x31","\xfc","\xf1"));
	outFields->push(HX_HCSTRING("_gamepadEvents","\xdb","\x42","\x7e","\xf3"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo InputController_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(InputController_obj,_keyboardEvents),HX_HCSTRING("_keyboardEvents","\xbf","\x3f","\xfe","\x64")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(InputController_obj,_mouseEvents),HX_HCSTRING("_mouseEvents","\x1f","\x31","\xfc","\xf1")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(InputController_obj,_gamepadEvents),HX_HCSTRING("_gamepadEvents","\xdb","\x42","\x7e","\xf3")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *InputController_obj_sStaticStorageInfo = 0;
#endif

static ::String InputController_obj_sMemberFields[] = {
	HX_HCSTRING("_keyboardEvents","\xbf","\x3f","\xfe","\x64"),
	HX_HCSTRING("_mouseEvents","\x1f","\x31","\xfc","\xf1"),
	HX_HCSTRING("_gamepadEvents","\xdb","\x42","\x7e","\xf3"),
	HX_HCSTRING("addKeyboardEvent","\x12","\x1b","\xc7","\x48"),
	HX_HCSTRING("addMouseEvent","\x36","\x05","\xdb","\xfd"),
	HX_HCSTRING("addGamepadEvent","\x7a","\xdb","\xe4","\xb3"),
	HX_HCSTRING("updateControls","\x9f","\x79","\xe6","\x6c"),
	::String(null()) };

static void InputController_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(InputController_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void InputController_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(InputController_obj::__mClass,"__mClass");
};

#endif

hx::Class InputController_obj::__mClass;

void InputController_obj::__register()
{
	hx::Object *dummy = new InputController_obj;
	InputController_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("InputController","\x26","\x99","\x26","\x13");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = InputController_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(InputController_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< InputController_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = InputController_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = InputController_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = InputController_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

