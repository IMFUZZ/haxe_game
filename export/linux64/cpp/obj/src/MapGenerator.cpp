// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_MapGenerator
#include <MapGenerator.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif

void MapGenerator_obj::__construct(Int a_size,Float a_displacement){
            	HX_STACK_FRAME("MapGenerator","new",0xa5e36ea9,"MapGenerator.new","MapGenerator.hx",12,0xd51ed8e7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(a_size,"a_size")
            	HX_STACK_ARG(a_displacement,"a_displacement")
HXLINE(  14)		Float _hx_tmp = ::Math_obj::pow((int)2,a_size);
HXDLIN(  14)		this->_size = ::Std_obj::_hx_int((_hx_tmp + (int)1));
HXLINE(  15)		this->_displacement = a_displacement;
HXLINE(  16)		this->table = ::Array_obj< ::Dynamic>::__new();
            	}

Dynamic MapGenerator_obj::__CreateEmpty() { return new MapGenerator_obj; }

hx::ObjectPtr< MapGenerator_obj > MapGenerator_obj::__new(Int a_size,Float a_displacement)
{
	hx::ObjectPtr< MapGenerator_obj > _hx_result = new MapGenerator_obj();
	_hx_result->__construct(a_size,a_displacement);
	return _hx_result;
}

Dynamic MapGenerator_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< MapGenerator_obj > _hx_result = new MapGenerator_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

::Array< ::Dynamic> MapGenerator_obj::generate(){
            	HX_STACK_FRAME("MapGenerator","generate",0x40c3584c,"MapGenerator.generate","MapGenerator.hx",19,0xd51ed8e7)
            	HX_STACK_THIS(this)
HXLINE(  20)		this->clear();
HXLINE(  21)		{
HXLINE(  21)			Int _g1 = (int)0;
HXDLIN(  21)			Int _g = this->_size;
HXDLIN(  21)			while((_g1 < _g)){
HXLINE(  21)				Int x = _g1++;
HXLINE(  22)				this->table->push(::Array_obj< Int >::__new());
HXLINE(  23)				{
HXLINE(  23)					Int _g3 = (int)0;
HXDLIN(  23)					Int _g2 = this->_size;
HXDLIN(  23)					while((_g3 < _g2)){
HXLINE(  23)						++_g3;
HXLINE(  24)						this->table->__get(x).StaticCast< ::Array< Int > >()->push((int)-1);
            					}
            				}
            			}
            		}
HXLINE(  27)		::Array< Int > _hx_tmp = this->table->__get((int)0).StaticCast< ::Array< Int > >();
HXDLIN(  27)		Float _hx_tmp1 = ::Math_obj::random();
HXDLIN(  27)		Int _hx_tmp2 = ::Std_obj::_hx_int(_hx_tmp1);
HXDLIN(  27)		_hx_tmp[(int)0] = _hx_tmp2;
HXLINE(  28)		::Array< Int > _hx_tmp3 = this->table->__get((int)0).StaticCast< ::Array< Int > >();
HXDLIN(  28)		Int _hx_tmp4 = (this->_size - (int)1);
HXDLIN(  28)		Float _hx_tmp5 = ::Math_obj::random();
HXDLIN(  28)		Int _hx_tmp6 = ::Std_obj::_hx_int(_hx_tmp5);
HXDLIN(  28)		_hx_tmp3[_hx_tmp4] = _hx_tmp6;
HXLINE(  29)		::Array< Int > _hx_tmp7 = this->table->__get((this->_size - (int)1)).StaticCast< ::Array< Int > >();
HXDLIN(  29)		Float _hx_tmp8 = ::Math_obj::random();
HXDLIN(  29)		Int _hx_tmp9 = ::Std_obj::_hx_int(_hx_tmp8);
HXDLIN(  29)		_hx_tmp7[(int)0] = _hx_tmp9;
HXLINE(  30)		::Array< Int > _hx_tmp10 = this->table->__get((this->_size - (int)1)).StaticCast< ::Array< Int > >();
HXDLIN(  30)		Int _hx_tmp11 = (this->_size - (int)1);
HXDLIN(  30)		Float _hx_tmp12 = ::Math_obj::random();
HXDLIN(  30)		Int _hx_tmp13 = ::Std_obj::_hx_int(_hx_tmp12);
HXDLIN(  30)		_hx_tmp10[_hx_tmp11] = _hx_tmp13;
HXLINE(  31)		Int _hx_tmp14 = (this->_size - (int)1);
HXDLIN(  31)		Int _hx_tmp15 = (this->_size - (int)1);
HXDLIN(  31)		this->table = this->divide(this->table,(int)0,(int)0,_hx_tmp14,_hx_tmp15,this->_displacement);
HXLINE(  32)		::Array< ::Dynamic> worldMap = this->transformToValueRange((int)4);
HXLINE(  33)		return worldMap;
            	}


HX_DEFINE_DYNAMIC_FUNC0(MapGenerator_obj,generate,return )

void MapGenerator_obj::clear(){
            	HX_STACK_FRAME("MapGenerator","clear",0x27c5f416,"MapGenerator.clear","MapGenerator.hx",38,0xd51ed8e7)
            	HX_STACK_THIS(this)
HXLINE(  38)		this->table->removeRange((int)0,this->table->length);
            	}


HX_DEFINE_DYNAMIC_FUNC0(MapGenerator_obj,clear,(void))

::Array< ::Dynamic> MapGenerator_obj::divide(::Array< ::Dynamic> a_table,Int x1,Int y1,Int x2,Int y2,Float a_displacement){
            	HX_STACK_FRAME("MapGenerator","divide",0x5cd9e4d0,"MapGenerator.divide","MapGenerator.hx",44,0xd51ed8e7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(a_table,"a_table")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(y1,"y1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(y2,"y2")
            	HX_STACK_ARG(a_displacement,"a_displacement")
HXLINE(  45)		Int diffX = (x2 - x1);
HXLINE(  46)		Int diffY = (y2 - y1);
HXLINE(  47)		Int cx = ::Std_obj::_hx_int((x1 + ((Float)diffX / (Float)(int)2)));
HXLINE(  48)		Int cy = ::Std_obj::_hx_int((y1 + ((Float)diffY / (Float)(int)2)));
HXLINE(  49)		Float d2 = ((Float)a_displacement / (Float)(int)2);
HXLINE(  50)		if ((diffX > (int)1)) {
HXLINE(  51)			::Array< Int > _hx_tmp = a_table->__get(cy).StaticCast< ::Array< Int > >();
HXDLIN(  51)			Float _hx_tmp1 = ((Float)(((a_table->__get(y1).StaticCast< ::Array< Int > >()->__get(x1) + a_table->__get(y2).StaticCast< ::Array< Int > >()->__get(x2)) + a_table->__get(y1).StaticCast< ::Array< Int > >()->__get(x2)) + a_table->__get(y2).StaticCast< ::Array< Int > >()->__get(x1)) / (Float)(int)4);
HXDLIN(  51)			Float _hx_tmp2 = ::Math_obj::random();
HXDLIN(  51)			Int _hx_tmp3 = ::Std_obj::_hx_int(((_hx_tmp1 + ((_hx_tmp2 * (int)10) * a_displacement)) - d2));
HXDLIN(  51)			_hx_tmp[cx] = _hx_tmp3;
HXLINE(  52)			if ((a_table->__get(y1).StaticCast< ::Array< Int > >()->__get(cx) == (int)-1)) {
HXLINE(  53)				::Array< Int > _hx_tmp4 = a_table->__get(y1).StaticCast< ::Array< Int > >();
HXDLIN(  53)				Float _hx_tmp5 = ((Float)(a_table->__get(y1).StaticCast< ::Array< Int > >()->__get(x1) + a_table->__get(y1).StaticCast< ::Array< Int > >()->__get(x2)) / (Float)(int)2);
HXDLIN(  53)				Float _hx_tmp6 = ::Math_obj::random();
HXDLIN(  53)				Int _hx_tmp7 = ::Std_obj::_hx_int(((_hx_tmp5 + ((_hx_tmp6 * (int)10) * a_displacement)) - d2));
HXDLIN(  53)				_hx_tmp4[cx] = _hx_tmp7;
            			}
HXLINE(  55)			if ((a_table->__get(y2).StaticCast< ::Array< Int > >()->__get(cx) == (int)-1)) {
HXLINE(  56)				::Array< Int > _hx_tmp8 = a_table->__get(y2).StaticCast< ::Array< Int > >();
HXDLIN(  56)				Float _hx_tmp9 = ((Float)(a_table->__get(y2).StaticCast< ::Array< Int > >()->__get(x1) + a_table->__get(y2).StaticCast< ::Array< Int > >()->__get(x2)) / (Float)(int)2);
HXDLIN(  56)				Float _hx_tmp10 = ::Math_obj::random();
HXDLIN(  56)				Int _hx_tmp11 = ::Std_obj::_hx_int(((_hx_tmp9 + ((_hx_tmp10 * (int)10) * a_displacement)) - d2));
HXDLIN(  56)				_hx_tmp8[cx] = _hx_tmp11;
            			}
HXLINE(  58)			if ((a_table->__get(cy).StaticCast< ::Array< Int > >()->__get(x1) == (int)-1)) {
HXLINE(  59)				::Array< Int > _hx_tmp12 = a_table->__get(cy).StaticCast< ::Array< Int > >();
HXDLIN(  59)				Float _hx_tmp13 = ((Float)(a_table->__get(y1).StaticCast< ::Array< Int > >()->__get(x1) + a_table->__get(y2).StaticCast< ::Array< Int > >()->__get(x1)) / (Float)(int)2);
HXDLIN(  59)				Float _hx_tmp14 = ::Math_obj::random();
HXDLIN(  59)				Int _hx_tmp15 = ::Std_obj::_hx_int(((_hx_tmp13 + ((_hx_tmp14 * (int)10) * a_displacement)) - d2));
HXDLIN(  59)				_hx_tmp12[x1] = _hx_tmp15;
            			}
HXLINE(  61)			if ((a_table->__get(cy).StaticCast< ::Array< Int > >()->__get(x2) == (int)-1)) {
HXLINE(  62)				::Array< Int > _hx_tmp16 = a_table->__get(cy).StaticCast< ::Array< Int > >();
HXDLIN(  62)				Float _hx_tmp17 = ((Float)(a_table->__get(y1).StaticCast< ::Array< Int > >()->__get(x2) + a_table->__get(y2).StaticCast< ::Array< Int > >()->__get(x2)) / (Float)(int)2);
HXDLIN(  62)				Float _hx_tmp18 = ::Math_obj::random();
HXDLIN(  62)				Int _hx_tmp19 = ::Std_obj::_hx_int(((_hx_tmp17 + ((_hx_tmp18 * (int)10) * a_displacement)) - d2));
HXDLIN(  62)				_hx_tmp16[x2] = _hx_tmp19;
            			}
HXLINE(  64)			Float new_displacement = ((Float)a_displacement / (Float)this->_displacement);
HXLINE(  65)			a_table = this->divide(a_table,x1,y1,cx,cy,new_displacement);
HXLINE(  66)			a_table = this->divide(a_table,cx,y1,x2,cy,new_displacement);
HXLINE(  67)			a_table = this->divide(a_table,x1,cy,cx,y2,new_displacement);
HXLINE(  68)			a_table = this->divide(a_table,cx,cy,x2,y2,new_displacement);
            		}
HXLINE(  70)		return a_table;
            	}


HX_DEFINE_DYNAMIC_FUNC6(MapGenerator_obj,divide,return )

::Array< ::Dynamic> MapGenerator_obj::transformToValueRange(Int a_valueRange){
            	HX_STACK_FRAME("MapGenerator","transformToValueRange",0xc78efdfc,"MapGenerator.transformToValueRange","MapGenerator.hx",73,0xd51ed8e7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(a_valueRange,"a_valueRange")
HXLINE(  74)		Int s = (int)-1;
HXLINE(  75)		Int b = (int)-1;
HXLINE(  76)		{
HXLINE(  76)			Int _g1 = (int)0;
HXDLIN(  76)			Int _g = this->table->length;
HXDLIN(  76)			while((_g1 < _g)){
HXLINE(  76)				Int y = _g1++;
HXLINE(  77)				{
HXLINE(  77)					Int _g3 = (int)0;
HXDLIN(  77)					Int _g2 = this->table->__get(y).StaticCast< ::Array< Int > >()->length;
HXDLIN(  77)					while((_g3 < _g2)){
HXLINE(  77)						Int x = _g3++;
HXLINE(  78)						Bool _hx_tmp;
HXDLIN(  78)						if ((s != (int)-1)) {
HXLINE(  78)							_hx_tmp = (this->table->__get(y).StaticCast< ::Array< Int > >()->__get(x) < s);
            						}
            						else {
HXLINE(  78)							_hx_tmp = true;
            						}
HXDLIN(  78)						if (_hx_tmp) {
HXLINE(  79)							s = this->table->__get(y).StaticCast< ::Array< Int > >()->__get(x);
            						}
HXLINE(  81)						Bool _hx_tmp1;
HXDLIN(  81)						if ((b != (int)-1)) {
HXLINE(  81)							_hx_tmp1 = (this->table->__get(y).StaticCast< ::Array< Int > >()->__get(x) > b);
            						}
            						else {
HXLINE(  81)							_hx_tmp1 = true;
            						}
HXDLIN(  81)						if (_hx_tmp1) {
HXLINE(  82)							b = this->table->__get(y).StaticCast< ::Array< Int > >()->__get(x);
            						}
            					}
            				}
            			}
            		}
HXLINE(  86)		Int diff = (b - s);
HXLINE(  87)		{
HXLINE(  87)			Int _g11 = (int)0;
HXDLIN(  87)			Int _g4 = this->table->length;
HXDLIN(  87)			while((_g11 < _g4)){
HXLINE(  87)				Int y1 = _g11++;
HXLINE(  88)				{
HXLINE(  88)					Int _g31 = (int)0;
HXDLIN(  88)					Int _g21 = this->table->__get(y1).StaticCast< ::Array< Int > >()->length;
HXDLIN(  88)					while((_g31 < _g21)){
HXLINE(  88)						Int x1 = _g31++;
HXLINE(  89)						if ((this->table->__get(y1).StaticCast< ::Array< Int > >()->__get(x1) <= (int)0)) {
HXLINE(  89)							this->table->__get(y1).StaticCast< ::Array< Int > >()[x1] = (int)1;
            						}
            						else {
HXLINE(  90)							::Array< Int > _hx_tmp2 = this->table->__get(y1).StaticCast< ::Array< Int > >();
HXDLIN(  90)							Int _hx_tmp3 = ::Std_obj::_hx_int((((Float)(this->table->__get(y1).StaticCast< ::Array< Int > >()->__get(x1) - s) / (Float)diff) * a_valueRange));
HXDLIN(  90)							_hx_tmp2[x1] = _hx_tmp3;
            						}
            					}
            				}
            			}
            		}
HXLINE(  93)		return this->table;
            	}


HX_DEFINE_DYNAMIC_FUNC1(MapGenerator_obj,transformToValueRange,return )

::Array< ::Dynamic> MapGenerator_obj::getViewable(Int tileSize){
            	HX_STACK_FRAME("MapGenerator","getViewable",0x2ad9887e,"MapGenerator.getViewable","MapGenerator.hx",96,0xd51ed8e7)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(tileSize,"tileSize")
HXLINE(  97)		Float _hx_tmp = (((Float)::flixel::FlxG_obj::camera->x / (Float)(int)16) * ::flixel::FlxG_obj::camera->zoom);
HXDLIN(  97)		Int indexAStart = ::Std_obj::_hx_int(_hx_tmp);
HXLINE(  98)		Float _hx_tmp1 = (((Float)(::flixel::FlxG_obj::camera->x + ::flixel::FlxG_obj::camera->width) / (Float)(int)16) * ::flixel::FlxG_obj::camera->zoom);
HXDLIN(  98)		Int indexAEnd = ::Std_obj::_hx_int(_hx_tmp1);
HXLINE(  99)		Float _hx_tmp2 = (((Float)::flixel::FlxG_obj::camera->y / (Float)(int)16) * ::flixel::FlxG_obj::camera->zoom);
HXDLIN(  99)		Int indexBStart = ::Std_obj::_hx_int(_hx_tmp2);
HXLINE( 100)		Float _hx_tmp3 = (((Float)(::flixel::FlxG_obj::camera->y + ::flixel::FlxG_obj::camera->height) / (Float)(int)16) * ::flixel::FlxG_obj::camera->zoom);
HXDLIN( 100)		Int indexBEnd = ::Std_obj::_hx_int(_hx_tmp3);
HXLINE( 101)		::Array< ::Dynamic> tempTable = ::Array_obj< ::Dynamic>::__new();
HXLINE( 102)		{
HXLINE( 102)			Int _g1 = indexBStart;
HXDLIN( 102)			while((_g1 < indexBEnd)){
HXLINE( 102)				Int y = _g1++;
HXLINE( 103)				tempTable->push(::Array_obj< Int >::__new());
HXLINE( 104)				{
HXLINE( 104)					Int _g3 = indexAStart;
HXDLIN( 104)					while((_g3 < indexAEnd)){
HXLINE( 104)						Int x = _g3++;
HXLINE( 105)						tempTable->__get(y).StaticCast< ::Array< Int > >()->push(this->table->__get(y).StaticCast< ::Array< Int > >()->__get(x));
            					}
            				}
            			}
            		}
HXLINE( 108)		return tempTable;
            	}


HX_DEFINE_DYNAMIC_FUNC1(MapGenerator_obj,getViewable,return )


MapGenerator_obj::MapGenerator_obj()
{
}

void MapGenerator_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(MapGenerator);
	HX_MARK_MEMBER_NAME(_size,"_size");
	HX_MARK_MEMBER_NAME(_displacement,"_displacement");
	HX_MARK_MEMBER_NAME(_valueRange,"_valueRange");
	HX_MARK_MEMBER_NAME(table,"table");
	HX_MARK_END_CLASS();
}

void MapGenerator_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_size,"_size");
	HX_VISIT_MEMBER_NAME(_displacement,"_displacement");
	HX_VISIT_MEMBER_NAME(_valueRange,"_valueRange");
	HX_VISIT_MEMBER_NAME(table,"table");
}

hx::Val MapGenerator_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_size") ) { return hx::Val( _size); }
		if (HX_FIELD_EQ(inName,"table") ) { return hx::Val( table); }
		if (HX_FIELD_EQ(inName,"clear") ) { return hx::Val( clear_dyn()); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"divide") ) { return hx::Val( divide_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"generate") ) { return hx::Val( generate_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_valueRange") ) { return hx::Val( _valueRange); }
		if (HX_FIELD_EQ(inName,"getViewable") ) { return hx::Val( getViewable_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_displacement") ) { return hx::Val( _displacement); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"transformToValueRange") ) { return hx::Val( transformToValueRange_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val MapGenerator_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_size") ) { _size=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"table") ) { table=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_valueRange") ) { _valueRange=inValue.Cast< Int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_displacement") ) { _displacement=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void MapGenerator_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("_size","\xa0","\xbc","\x64","\xff"));
	outFields->push(HX_HCSTRING("_displacement","\xb6","\xe5","\x91","\xff"));
	outFields->push(HX_HCSTRING("_valueRange","\xab","\xc9","\x45","\x5e"));
	outFields->push(HX_HCSTRING("table","\x0e","\xb8","\xe3","\x0a"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo MapGenerator_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(MapGenerator_obj,_size),HX_HCSTRING("_size","\xa0","\xbc","\x64","\xff")},
	{hx::fsFloat,(int)offsetof(MapGenerator_obj,_displacement),HX_HCSTRING("_displacement","\xb6","\xe5","\x91","\xff")},
	{hx::fsInt,(int)offsetof(MapGenerator_obj,_valueRange),HX_HCSTRING("_valueRange","\xab","\xc9","\x45","\x5e")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(MapGenerator_obj,table),HX_HCSTRING("table","\x0e","\xb8","\xe3","\x0a")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *MapGenerator_obj_sStaticStorageInfo = 0;
#endif

static ::String MapGenerator_obj_sMemberFields[] = {
	HX_HCSTRING("_size","\xa0","\xbc","\x64","\xff"),
	HX_HCSTRING("_displacement","\xb6","\xe5","\x91","\xff"),
	HX_HCSTRING("_valueRange","\xab","\xc9","\x45","\x5e"),
	HX_HCSTRING("table","\x0e","\xb8","\xe3","\x0a"),
	HX_HCSTRING("generate","\x35","\x5f","\xa2","\xd9"),
	HX_HCSTRING("clear","\x8d","\x71","\x5b","\x48"),
	HX_HCSTRING("divide","\x79","\x2f","\x12","\xbf"),
	HX_HCSTRING("transformToValueRange","\x73","\x19","\x05","\x0f"),
	HX_HCSTRING("getViewable","\x35","\xf9","\xa4","\xb8"),
	::String(null()) };

static void MapGenerator_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(MapGenerator_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void MapGenerator_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(MapGenerator_obj::__mClass,"__mClass");
};

#endif

hx::Class MapGenerator_obj::__mClass;

void MapGenerator_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("MapGenerator","\x37","\xe6","\xb2","\xf1");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = MapGenerator_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(MapGenerator_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< MapGenerator_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = MapGenerator_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = MapGenerator_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = MapGenerator_obj_sStaticStorageInfo;
#endif
	hx::RegisterClass(__mClass->mName, __mClass);
}

