// Generated by Haxe 3.4.0
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_nape_dynamics_Arbiter
#include <nape/dynamics/Arbiter.h>
#endif
#ifndef INCLUDED_nape_dynamics_CollisionArbiter
#include <nape/dynamics/CollisionArbiter.h>
#endif
#ifndef INCLUDED_nape_dynamics_Contact
#include <nape/dynamics/Contact.h>
#endif
#ifndef INCLUDED_nape_dynamics_ContactList
#include <nape/dynamics/ContactList.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_nape_geom_Vec3
#include <nape/geom/Vec3.h>
#endif
#ifndef INCLUDED_nape_phys_Body
#include <nape/phys/Body.h>
#endif
#ifndef INCLUDED_nape_phys_Interactor
#include <nape/phys/Interactor.h>
#endif
#ifndef INCLUDED_nape_shape_Edge
#include <nape/shape/Edge.h>
#endif
#ifndef INCLUDED_nape_shape_Shape
#include <nape/shape/Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_Arbiter
#include <zpp_nape/dynamics/ZPP_Arbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_ColArbiter
#include <zpp_nape/dynamics/ZPP_ColArbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_Contact
#include <zpp_nape/dynamics/ZPP_Contact.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec3
#include <zpp_nape/geom/ZPP_Vec3.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Material
#include <zpp_nape/phys/ZPP_Material.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Edge
#include <zpp_nape/shape/ZPP_Edge.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Polygon
#include <zpp_nape/shape/ZPP_Polygon.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Shape
#include <zpp_nape/shape/ZPP_Shape.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_732_new,"nape.dynamics.CollisionArbiter","new",0xd8a0cabd,"nape.dynamics.CollisionArbiter.new","nape/dynamics/CollisionArbiter.hx",732,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_183_get_contacts,"nape.dynamics.CollisionArbiter","get_contacts",0x33e1d7df,"nape.dynamics.CollisionArbiter.get_contacts","nape/dynamics/CollisionArbiter.hx",183,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_199_get_normal,"nape.dynamics.CollisionArbiter","get_normal",0x34ea9d33,"nape.dynamics.CollisionArbiter.get_normal","nape/dynamics/CollisionArbiter.hx",199,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_217_get_radius,"nape.dynamics.CollisionArbiter","get_radius",0xb577fb5e,"nape.dynamics.CollisionArbiter.get_radius","nape/dynamics/CollisionArbiter.hx",217,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_225_get_referenceEdge1,"nape.dynamics.CollisionArbiter","get_referenceEdge1",0x7f96cc95,"nape.dynamics.CollisionArbiter.get_referenceEdge1","nape/dynamics/CollisionArbiter.hx",225,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_239_get_referenceEdge2,"nape.dynamics.CollisionArbiter","get_referenceEdge2",0x7f96cc96,"nape.dynamics.CollisionArbiter.get_referenceEdge2","nape/dynamics/CollisionArbiter.hx",239,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_262_firstVertex,"nape.dynamics.CollisionArbiter","firstVertex",0xec742b11,"nape.dynamics.CollisionArbiter.firstVertex","nape/dynamics/CollisionArbiter.hx",262,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_281_secondVertex,"nape.dynamics.CollisionArbiter","secondVertex",0x2e747ffb,"nape.dynamics.CollisionArbiter.secondVertex","nape/dynamics/CollisionArbiter.hx",281,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_300_normalImpulse,"nape.dynamics.CollisionArbiter","normalImpulse",0xbc1d19eb,"nape.dynamics.CollisionArbiter.normalImpulse","nape/dynamics/CollisionArbiter.hx",300,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_394_tangentImpulse,"nape.dynamics.CollisionArbiter","tangentImpulse",0xec0a4733,"nape.dynamics.CollisionArbiter.tangentImpulse","nape/dynamics/CollisionArbiter.hx",394,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_485_totalImpulse,"nape.dynamics.CollisionArbiter","totalImpulse",0x690d3754,"nape.dynamics.CollisionArbiter.totalImpulse","nape/dynamics/CollisionArbiter.hx",485,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_573_rollingImpulse,"nape.dynamics.CollisionArbiter","rollingImpulse",0x51a9ce73,"nape.dynamics.CollisionArbiter.rollingImpulse","nape/dynamics/CollisionArbiter.hx",573,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_596_get_elasticity,"nape.dynamics.CollisionArbiter","get_elasticity",0x4a75c485,"nape.dynamics.CollisionArbiter.get_elasticity","nape/dynamics/CollisionArbiter.hx",596,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_604_set_elasticity,"nape.dynamics.CollisionArbiter","set_elasticity",0x6a95acf9,"nape.dynamics.CollisionArbiter.set_elasticity","nape/dynamics/CollisionArbiter.hx",604,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_631_get_dynamicFriction,"nape.dynamics.CollisionArbiter","get_dynamicFriction",0x4389ff0d,"nape.dynamics.CollisionArbiter.get_dynamicFriction","nape/dynamics/CollisionArbiter.hx",631,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_639_set_dynamicFriction,"nape.dynamics.CollisionArbiter","set_dynamicFriction",0x8026f219,"nape.dynamics.CollisionArbiter.set_dynamicFriction","nape/dynamics/CollisionArbiter.hx",639,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_666_get_staticFriction,"nape.dynamics.CollisionArbiter","get_staticFriction",0x9e3d86d4,"nape.dynamics.CollisionArbiter.get_staticFriction","nape/dynamics/CollisionArbiter.hx",666,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_674_set_staticFriction,"nape.dynamics.CollisionArbiter","set_staticFriction",0x7aecb948,"nape.dynamics.CollisionArbiter.set_staticFriction","nape/dynamics/CollisionArbiter.hx",674,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_701_get_rollingFriction,"nape.dynamics.CollisionArbiter","get_rollingFriction",0x20008313,"nape.dynamics.CollisionArbiter.get_rollingFriction","nape/dynamics/CollisionArbiter.hx",701,0xb8178f73)
HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_709_set_rollingFriction,"nape.dynamics.CollisionArbiter","set_rollingFriction",0x5c9d761f,"nape.dynamics.CollisionArbiter.set_rollingFriction","nape/dynamics/CollisionArbiter.hx",709,0xb8178f73)
namespace nape{
namespace dynamics{

void CollisionArbiter_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_732_new)
            	HX_STACK_THIS(this)
HXLINE( 732)		super::__construct();
            	}

Dynamic CollisionArbiter_obj::__CreateEmpty() { return new CollisionArbiter_obj; }

void *CollisionArbiter_obj::_hx_vtable = 0;

Dynamic CollisionArbiter_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< CollisionArbiter_obj > _hx_result = new CollisionArbiter_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool CollisionArbiter_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x3d1477e9) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x3d1477e9;
	} else {
		return inClassId==(int)0x7dbe69fb;
	}
}

 ::nape::dynamics::ContactList CollisionArbiter_obj::get_contacts(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_183_get_contacts)
            	HX_STACK_THIS(this)
HXLINE( 187)		if (hx::IsNull( this->zpp_inner->colarb->wrap_contacts )) {
HXLINE( 187)			this->zpp_inner->colarb->setupcontacts();
            		}
HXLINE( 188)		return this->zpp_inner->colarb->wrap_contacts;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_contacts,return )

 ::nape::geom::Vec2 CollisionArbiter_obj::get_normal(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_199_get_normal)
            	HX_STACK_THIS(this)
HXLINE( 203)		if (hx::IsNull( this->zpp_inner->colarb->wrap_normal )) {
HXLINE( 203)			this->zpp_inner->colarb->getnormal();
            		}
HXLINE( 204)		return this->zpp_inner->colarb->wrap_normal;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_normal,return )

Float CollisionArbiter_obj::get_radius(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_217_get_radius)
            	HX_STACK_THIS(this)
HXLINE( 217)		return this->zpp_inner->colarb->radius;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_radius,return )

 ::nape::shape::Edge CollisionArbiter_obj::get_referenceEdge1(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_225_get_referenceEdge1)
            	HX_STACK_THIS(this)
HXLINE( 229)		HX_VARI(  ::zpp_nape::shape::ZPP_Edge,edge) = this->zpp_inner->colarb->_hx___ref_edge1;
HXLINE( 230)		bool _hx_tmp;
HXDLIN( 230)		if (hx::IsNotNull( edge )) {
HXLINE( 230)			 ::nape::shape::Shape _this;
HXDLIN( 230)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 230)				_this = this->zpp_inner->ws2->outer;
            			}
            			else {
HXLINE( 230)				_this = this->zpp_inner->ws1->outer;
            			}
HXDLIN( 230)			if (!((_this->zpp_inner->type != (int)1))) {
HXLINE( 230)				 ::nape::shape::Shape _hx_tmp1;
HXDLIN( 230)				if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 230)					_hx_tmp1 = this->zpp_inner->ws2->outer;
            				}
            				else {
HXLINE( 230)					_hx_tmp1 = this->zpp_inner->ws1->outer;
            				}
HXDLIN( 230)				_hx_tmp = hx::IsNotEq( _hx_tmp1->zpp_inner,edge->polygon );
            			}
            			else {
HXLINE( 230)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE( 230)			_hx_tmp = false;
            		}
HXDLIN( 230)		if (_hx_tmp) {
HXLINE( 230)			edge = this->zpp_inner->colarb->_hx___ref_edge2;
            		}
HXLINE( 231)		if (hx::IsNull( edge )) {
HXLINE( 231)			return null();
            		}
            		else {
HXLINE( 231)			return edge->wrapper();
            		}
HXDLIN( 231)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_referenceEdge1,return )

 ::nape::shape::Edge CollisionArbiter_obj::get_referenceEdge2(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_239_get_referenceEdge2)
            	HX_STACK_THIS(this)
HXLINE( 243)		HX_VARI(  ::zpp_nape::shape::ZPP_Edge,edge) = this->zpp_inner->colarb->_hx___ref_edge1;
HXLINE( 244)		bool _hx_tmp;
HXDLIN( 244)		if (hx::IsNotNull( edge )) {
HXLINE( 244)			 ::nape::shape::Shape _this;
HXDLIN( 244)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 244)				_this = this->zpp_inner->ws1->outer;
            			}
            			else {
HXLINE( 244)				_this = this->zpp_inner->ws2->outer;
            			}
HXDLIN( 244)			if (!((_this->zpp_inner->type != (int)1))) {
HXLINE( 244)				 ::nape::shape::Shape _hx_tmp1;
HXDLIN( 244)				if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 244)					_hx_tmp1 = this->zpp_inner->ws1->outer;
            				}
            				else {
HXLINE( 244)					_hx_tmp1 = this->zpp_inner->ws2->outer;
            				}
HXDLIN( 244)				_hx_tmp = hx::IsNotEq( _hx_tmp1->zpp_inner,edge->polygon );
            			}
            			else {
HXLINE( 244)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE( 244)			_hx_tmp = false;
            		}
HXDLIN( 244)		if (_hx_tmp) {
HXLINE( 244)			edge = this->zpp_inner->colarb->_hx___ref_edge2;
            		}
HXLINE( 245)		if (hx::IsNull( edge )) {
HXLINE( 245)			return null();
            		}
            		else {
HXLINE( 245)			return edge->wrapper();
            		}
HXDLIN( 245)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_referenceEdge2,return )

bool CollisionArbiter_obj::firstVertex(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_262_firstVertex)
            	HX_STACK_THIS(this)
HXLINE( 262)		if ((hx::IsNotNull( this->zpp_inner->colarb->_hx___ref_edge1 ) != hx::IsNotNull( this->zpp_inner->colarb->_hx___ref_edge2 ))) {
HXLINE( 262)			return (this->zpp_inner->colarb->_hx___ref_vertex == (int)-1);
            		}
            		else {
HXLINE( 262)			return false;
            		}
HXDLIN( 262)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,firstVertex,return )

bool CollisionArbiter_obj::secondVertex(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_281_secondVertex)
            	HX_STACK_THIS(this)
HXLINE( 281)		if ((hx::IsNotNull( this->zpp_inner->colarb->_hx___ref_edge1 ) != hx::IsNotNull( this->zpp_inner->colarb->_hx___ref_edge2 ))) {
HXLINE( 281)			return (this->zpp_inner->colarb->_hx___ref_vertex == (int)1);
            		}
            		else {
HXLINE( 281)			return false;
            		}
HXDLIN( 281)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,secondVertex,return )

 ::nape::geom::Vec3 CollisionArbiter_obj::normalImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_300_normalImpulse)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(body,"body")
            	HX_STACK_ARG(freshOnly,"freshOnly")
HXLINE( 307)		HX_VARI( Float,retx) = (int)0;
HXLINE( 308)		HX_VARI( Float,rety) = (int)0;
HXLINE( 325)		HX_VARI( Float,retz) = (int)0;
HXLINE( 326)		HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 328)		bool _hx_tmp;
HXDLIN( 328)		if (!(!(freshOnly))) {
HXLINE( 328)			_hx_tmp = colarb->oc1->fresh;
            		}
            		else {
HXLINE( 328)			_hx_tmp = true;
            		}
HXDLIN( 328)		if (_hx_tmp) {
HXLINE( 329)			HX_VARI(  ::nape::geom::Vec3,imp) = colarb->oc1->wrapper()->normalImpulse(body);
HXLINE( 330)			{
HXLINE( 332)				{
HXLINE( 342)					{
HXLINE( 342)						HX_VARI(  ::zpp_nape::geom::ZPP_Vec3,_this) = imp->zpp_inner;
HXDLIN( 342)						if (hx::IsNotNull( _this->_validate )) {
HXLINE( 342)							_this->_validate();
            						}
            					}
HXDLIN( 342)					retx = (retx + imp->zpp_inner->x);
HXLINE( 343)					{
HXLINE( 343)						HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this1,"_this") = imp->zpp_inner;
HXDLIN( 343)						if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 343)							_this1->_validate();
            						}
            					}
HXDLIN( 343)					rety = (rety + imp->zpp_inner->y);
            				}
HXLINE( 345)				{
HXLINE( 345)					HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this2,"_this") = imp->zpp_inner;
HXDLIN( 345)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 345)						_this2->_validate();
            					}
            				}
HXDLIN( 345)				retz = (retz + imp->zpp_inner->z);
            			}
HXLINE( 347)			imp->dispose();
            		}
HXLINE( 350)		if (colarb->hc2) {
HXLINE( 351)			bool _hx_tmp1;
HXDLIN( 351)			if (!(!(freshOnly))) {
HXLINE( 351)				_hx_tmp1 = colarb->oc2->fresh;
            			}
            			else {
HXLINE( 351)				_hx_tmp1 = true;
            			}
HXDLIN( 351)			if (_hx_tmp1) {
HXLINE( 352)				HX_VARI_NAME(  ::nape::geom::Vec3,imp1,"imp") = colarb->oc2->wrapper()->normalImpulse(body);
HXLINE( 353)				{
HXLINE( 355)					{
HXLINE( 365)						{
HXLINE( 365)							HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this3,"_this") = imp1->zpp_inner;
HXDLIN( 365)							if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 365)								_this3->_validate();
            							}
            						}
HXDLIN( 365)						retx = (retx + imp1->zpp_inner->x);
HXLINE( 366)						{
HXLINE( 366)							HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this4,"_this") = imp1->zpp_inner;
HXDLIN( 366)							if (hx::IsNotNull( _this4->_validate )) {
HXLINE( 366)								_this4->_validate();
            							}
            						}
HXDLIN( 366)						rety = (rety + imp1->zpp_inner->y);
            					}
HXLINE( 368)					{
HXLINE( 368)						HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this5,"_this") = imp1->zpp_inner;
HXDLIN( 368)						if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 368)							_this5->_validate();
            						}
            					}
HXDLIN( 368)					retz = (retz + imp1->zpp_inner->z);
            				}
HXLINE( 370)				imp1->dispose();
            			}
            		}
HXLINE( 373)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC2(CollisionArbiter_obj,normalImpulse,return )

 ::nape::geom::Vec3 CollisionArbiter_obj::tangentImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_394_tangentImpulse)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(body,"body")
            	HX_STACK_ARG(freshOnly,"freshOnly")
HXLINE( 401)		HX_VARI( Float,retx) = (int)0;
HXLINE( 402)		HX_VARI( Float,rety) = (int)0;
HXLINE( 419)		HX_VARI( Float,retz) = (int)0;
HXLINE( 420)		HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 422)		bool _hx_tmp;
HXDLIN( 422)		if (!(!(freshOnly))) {
HXLINE( 422)			_hx_tmp = colarb->oc1->fresh;
            		}
            		else {
HXLINE( 422)			_hx_tmp = true;
            		}
HXDLIN( 422)		if (_hx_tmp) {
HXLINE( 423)			HX_VARI(  ::nape::geom::Vec3,imp) = colarb->oc1->wrapper()->tangentImpulse(body);
HXLINE( 424)			{
HXLINE( 426)				{
HXLINE( 436)					{
HXLINE( 436)						HX_VARI(  ::zpp_nape::geom::ZPP_Vec3,_this) = imp->zpp_inner;
HXDLIN( 436)						if (hx::IsNotNull( _this->_validate )) {
HXLINE( 436)							_this->_validate();
            						}
            					}
HXDLIN( 436)					retx = (retx + imp->zpp_inner->x);
HXLINE( 437)					{
HXLINE( 437)						HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this1,"_this") = imp->zpp_inner;
HXDLIN( 437)						if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 437)							_this1->_validate();
            						}
            					}
HXDLIN( 437)					rety = (rety + imp->zpp_inner->y);
            				}
HXLINE( 439)				{
HXLINE( 439)					HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this2,"_this") = imp->zpp_inner;
HXDLIN( 439)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 439)						_this2->_validate();
            					}
            				}
HXDLIN( 439)				retz = (retz + imp->zpp_inner->z);
            			}
HXLINE( 441)			imp->dispose();
            		}
HXLINE( 444)		if (colarb->hc2) {
HXLINE( 445)			bool _hx_tmp1;
HXDLIN( 445)			if (!(!(freshOnly))) {
HXLINE( 445)				_hx_tmp1 = colarb->oc2->fresh;
            			}
            			else {
HXLINE( 445)				_hx_tmp1 = true;
            			}
HXDLIN( 445)			if (_hx_tmp1) {
HXLINE( 446)				HX_VARI_NAME(  ::nape::geom::Vec3,imp1,"imp") = colarb->oc2->wrapper()->tangentImpulse(body);
HXLINE( 447)				{
HXLINE( 449)					{
HXLINE( 459)						{
HXLINE( 459)							HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this3,"_this") = imp1->zpp_inner;
HXDLIN( 459)							if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 459)								_this3->_validate();
            							}
            						}
HXDLIN( 459)						retx = (retx + imp1->zpp_inner->x);
HXLINE( 460)						{
HXLINE( 460)							HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this4,"_this") = imp1->zpp_inner;
HXDLIN( 460)							if (hx::IsNotNull( _this4->_validate )) {
HXLINE( 460)								_this4->_validate();
            							}
            						}
HXDLIN( 460)						rety = (rety + imp1->zpp_inner->y);
            					}
HXLINE( 462)					{
HXLINE( 462)						HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this5,"_this") = imp1->zpp_inner;
HXDLIN( 462)						if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 462)							_this5->_validate();
            						}
            					}
HXDLIN( 462)					retz = (retz + imp1->zpp_inner->z);
            				}
HXLINE( 464)				imp1->dispose();
            			}
            		}
HXLINE( 467)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC2(CollisionArbiter_obj,tangentImpulse,return )

 ::nape::geom::Vec3 CollisionArbiter_obj::totalImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_485_totalImpulse)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(body,"body")
            	HX_STACK_ARG(freshOnly,"freshOnly")
HXLINE( 492)		HX_VARI( Float,retx) = (int)0;
HXLINE( 493)		HX_VARI( Float,rety) = (int)0;
HXLINE( 510)		HX_VARI( Float,retz) = (int)0;
HXLINE( 511)		HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 513)		bool _hx_tmp;
HXDLIN( 513)		if (!(!(freshOnly))) {
HXLINE( 513)			_hx_tmp = colarb->oc1->fresh;
            		}
            		else {
HXLINE( 513)			_hx_tmp = true;
            		}
HXDLIN( 513)		if (_hx_tmp) {
HXLINE( 514)			HX_VARI(  ::nape::geom::Vec3,imp) = colarb->oc1->wrapper()->totalImpulse(body);
HXLINE( 515)			{
HXLINE( 517)				{
HXLINE( 527)					{
HXLINE( 527)						HX_VARI(  ::zpp_nape::geom::ZPP_Vec3,_this) = imp->zpp_inner;
HXDLIN( 527)						if (hx::IsNotNull( _this->_validate )) {
HXLINE( 527)							_this->_validate();
            						}
            					}
HXDLIN( 527)					retx = (retx + imp->zpp_inner->x);
HXLINE( 528)					{
HXLINE( 528)						HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this1,"_this") = imp->zpp_inner;
HXDLIN( 528)						if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 528)							_this1->_validate();
            						}
            					}
HXDLIN( 528)					rety = (rety + imp->zpp_inner->y);
            				}
HXLINE( 530)				{
HXLINE( 530)					HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this2,"_this") = imp->zpp_inner;
HXDLIN( 530)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 530)						_this2->_validate();
            					}
            				}
HXDLIN( 530)				retz = (retz + imp->zpp_inner->z);
            			}
HXLINE( 532)			imp->dispose();
            		}
HXLINE( 535)		if (colarb->hc2) {
HXLINE( 536)			bool _hx_tmp1;
HXDLIN( 536)			if (!(!(freshOnly))) {
HXLINE( 536)				_hx_tmp1 = colarb->oc2->fresh;
            			}
            			else {
HXLINE( 536)				_hx_tmp1 = true;
            			}
HXDLIN( 536)			if (_hx_tmp1) {
HXLINE( 537)				HX_VARI_NAME(  ::nape::geom::Vec3,imp1,"imp") = colarb->oc2->wrapper()->totalImpulse(body);
HXLINE( 538)				{
HXLINE( 540)					{
HXLINE( 550)						{
HXLINE( 550)							HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this3,"_this") = imp1->zpp_inner;
HXDLIN( 550)							if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 550)								_this3->_validate();
            							}
            						}
HXDLIN( 550)						retx = (retx + imp1->zpp_inner->x);
HXLINE( 551)						{
HXLINE( 551)							HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this4,"_this") = imp1->zpp_inner;
HXDLIN( 551)							if (hx::IsNotNull( _this4->_validate )) {
HXLINE( 551)								_this4->_validate();
            							}
            						}
HXDLIN( 551)						rety = (rety + imp1->zpp_inner->y);
            					}
HXLINE( 553)					{
HXLINE( 553)						HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec3,_this5,"_this") = imp1->zpp_inner;
HXDLIN( 553)						if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 553)							_this5->_validate();
            						}
            					}
HXDLIN( 553)					retz = (retz + imp1->zpp_inner->z);
            				}
HXLINE( 555)				imp1->dispose();
            			}
            		}
HXLINE( 558)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


Float CollisionArbiter_obj::rollingImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_573_rollingImpulse)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(body,"body")
            	HX_STACK_ARG(freshOnly,"freshOnly")
HXLINE( 580)		HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 581)		bool _hx_tmp;
HXDLIN( 581)		if (!(!(freshOnly))) {
HXLINE( 581)			_hx_tmp = colarb->oc1->fresh;
            		}
            		else {
HXLINE( 581)			_hx_tmp = true;
            		}
HXDLIN( 581)		if (_hx_tmp) {
HXLINE( 581)			return colarb->oc1->wrapper()->rollingImpulse(body);
            		}
            		else {
HXLINE( 582)			return ((Float)0.0);
            		}
HXLINE( 581)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC2(CollisionArbiter_obj,rollingImpulse,return )

Float CollisionArbiter_obj::get_elasticity(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_596_get_elasticity)
            	HX_STACK_THIS(this)
HXLINE( 600)		HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 601)		if (colarb->invalidated) {
HXLINE( 601)			colarb->invalidated = false;
HXDLIN( 601)			{
HXLINE( 601)				if (!(colarb->userdef_restitution)) {
HXLINE( 601)					bool _hx_tmp;
HXDLIN( 601)					if (!((colarb->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 601)						_hx_tmp = (colarb->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 601)						_hx_tmp = true;
            					}
HXDLIN( 601)					if (_hx_tmp) {
HXLINE( 601)						colarb->restitution = (int)0;
            					}
            					else {
HXLINE( 601)						bool _hx_tmp1;
HXDLIN( 601)						if (!((colarb->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 601)							_hx_tmp1 = (colarb->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 601)							_hx_tmp1 = true;
            						}
HXDLIN( 601)						if (_hx_tmp1) {
HXLINE( 601)							colarb->restitution = (int)1;
            						}
            						else {
HXLINE( 601)							colarb->restitution = ((Float)(colarb->s1->material->elasticity + colarb->s2->material->elasticity) / (Float)(int)2);
            						}
            					}
HXDLIN( 601)					if ((colarb->restitution < (int)0)) {
HXLINE( 601)						colarb->restitution = (int)0;
            					}
HXDLIN( 601)					if ((colarb->restitution > (int)1)) {
HXLINE( 601)						colarb->restitution = (int)1;
            					}
            				}
HXDLIN( 601)				if (!(colarb->userdef_dyn_fric)) {
HXLINE( 601)					colarb->dyn_fric = ::Math_obj::sqrt((colarb->s1->material->dynamicFriction * colarb->s2->material->dynamicFriction));
            				}
HXDLIN( 601)				if (!(colarb->userdef_stat_fric)) {
HXLINE( 601)					colarb->stat_fric = ::Math_obj::sqrt((colarb->s1->material->staticFriction * colarb->s2->material->staticFriction));
            				}
HXDLIN( 601)				if (!(colarb->userdef_rfric)) {
HXLINE( 601)					colarb->rfric = ::Math_obj::sqrt((colarb->s1->material->rollingFriction * colarb->s2->material->rollingFriction));
            				}
            			}
            		}
HXLINE( 602)		return colarb->restitution;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_elasticity,return )

Float CollisionArbiter_obj::set_elasticity(Float elasticity){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_604_set_elasticity)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(elasticity,"elasticity")
HXLINE( 605)		{
HXLINE( 614)			HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 615)			colarb->restitution = elasticity;
HXLINE( 616)			colarb->userdef_restitution = true;
            		}
HXLINE( 618)		HX_VARI_NAME(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb1,"colarb") = this->zpp_inner->colarb;
HXDLIN( 618)		if (colarb1->invalidated) {
HXLINE( 618)			colarb1->invalidated = false;
HXDLIN( 618)			{
HXLINE( 618)				if (!(colarb1->userdef_restitution)) {
HXLINE( 618)					bool _hx_tmp;
HXDLIN( 618)					if (!((colarb1->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 618)						_hx_tmp = (colarb1->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 618)						_hx_tmp = true;
            					}
HXDLIN( 618)					if (_hx_tmp) {
HXLINE( 618)						colarb1->restitution = (int)0;
            					}
            					else {
HXLINE( 618)						bool _hx_tmp1;
HXDLIN( 618)						if (!((colarb1->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 618)							_hx_tmp1 = (colarb1->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 618)							_hx_tmp1 = true;
            						}
HXDLIN( 618)						if (_hx_tmp1) {
HXLINE( 618)							colarb1->restitution = (int)1;
            						}
            						else {
HXLINE( 618)							colarb1->restitution = ((Float)(colarb1->s1->material->elasticity + colarb1->s2->material->elasticity) / (Float)(int)2);
            						}
            					}
HXDLIN( 618)					if ((colarb1->restitution < (int)0)) {
HXLINE( 618)						colarb1->restitution = (int)0;
            					}
HXDLIN( 618)					if ((colarb1->restitution > (int)1)) {
HXLINE( 618)						colarb1->restitution = (int)1;
            					}
            				}
HXDLIN( 618)				if (!(colarb1->userdef_dyn_fric)) {
HXLINE( 618)					colarb1->dyn_fric = ::Math_obj::sqrt((colarb1->s1->material->dynamicFriction * colarb1->s2->material->dynamicFriction));
            				}
HXDLIN( 618)				if (!(colarb1->userdef_stat_fric)) {
HXLINE( 618)					colarb1->stat_fric = ::Math_obj::sqrt((colarb1->s1->material->staticFriction * colarb1->s2->material->staticFriction));
            				}
HXDLIN( 618)				if (!(colarb1->userdef_rfric)) {
HXLINE( 618)					colarb1->rfric = ::Math_obj::sqrt((colarb1->s1->material->rollingFriction * colarb1->s2->material->rollingFriction));
            				}
            			}
            		}
HXDLIN( 618)		return colarb1->restitution;
            	}


HX_DEFINE_DYNAMIC_FUNC1(CollisionArbiter_obj,set_elasticity,return )

Float CollisionArbiter_obj::get_dynamicFriction(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_631_get_dynamicFriction)
            	HX_STACK_THIS(this)
HXLINE( 635)		HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 636)		if (colarb->invalidated) {
HXLINE( 636)			colarb->invalidated = false;
HXDLIN( 636)			{
HXLINE( 636)				if (!(colarb->userdef_restitution)) {
HXLINE( 636)					bool _hx_tmp;
HXDLIN( 636)					if (!((colarb->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 636)						_hx_tmp = (colarb->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 636)						_hx_tmp = true;
            					}
HXDLIN( 636)					if (_hx_tmp) {
HXLINE( 636)						colarb->restitution = (int)0;
            					}
            					else {
HXLINE( 636)						bool _hx_tmp1;
HXDLIN( 636)						if (!((colarb->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 636)							_hx_tmp1 = (colarb->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 636)							_hx_tmp1 = true;
            						}
HXDLIN( 636)						if (_hx_tmp1) {
HXLINE( 636)							colarb->restitution = (int)1;
            						}
            						else {
HXLINE( 636)							colarb->restitution = ((Float)(colarb->s1->material->elasticity + colarb->s2->material->elasticity) / (Float)(int)2);
            						}
            					}
HXDLIN( 636)					if ((colarb->restitution < (int)0)) {
HXLINE( 636)						colarb->restitution = (int)0;
            					}
HXDLIN( 636)					if ((colarb->restitution > (int)1)) {
HXLINE( 636)						colarb->restitution = (int)1;
            					}
            				}
HXDLIN( 636)				if (!(colarb->userdef_dyn_fric)) {
HXLINE( 636)					colarb->dyn_fric = ::Math_obj::sqrt((colarb->s1->material->dynamicFriction * colarb->s2->material->dynamicFriction));
            				}
HXDLIN( 636)				if (!(colarb->userdef_stat_fric)) {
HXLINE( 636)					colarb->stat_fric = ::Math_obj::sqrt((colarb->s1->material->staticFriction * colarb->s2->material->staticFriction));
            				}
HXDLIN( 636)				if (!(colarb->userdef_rfric)) {
HXLINE( 636)					colarb->rfric = ::Math_obj::sqrt((colarb->s1->material->rollingFriction * colarb->s2->material->rollingFriction));
            				}
            			}
            		}
HXLINE( 637)		return colarb->dyn_fric;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_dynamicFriction,return )

Float CollisionArbiter_obj::set_dynamicFriction(Float dynamicFriction){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_639_set_dynamicFriction)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(dynamicFriction,"dynamicFriction")
HXLINE( 640)		{
HXLINE( 649)			HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 650)			colarb->dyn_fric = dynamicFriction;
HXLINE( 651)			colarb->userdef_dyn_fric = true;
            		}
HXLINE( 653)		HX_VARI_NAME(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb1,"colarb") = this->zpp_inner->colarb;
HXDLIN( 653)		if (colarb1->invalidated) {
HXLINE( 653)			colarb1->invalidated = false;
HXDLIN( 653)			{
HXLINE( 653)				if (!(colarb1->userdef_restitution)) {
HXLINE( 653)					bool _hx_tmp;
HXDLIN( 653)					if (!((colarb1->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 653)						_hx_tmp = (colarb1->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 653)						_hx_tmp = true;
            					}
HXDLIN( 653)					if (_hx_tmp) {
HXLINE( 653)						colarb1->restitution = (int)0;
            					}
            					else {
HXLINE( 653)						bool _hx_tmp1;
HXDLIN( 653)						if (!((colarb1->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 653)							_hx_tmp1 = (colarb1->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 653)							_hx_tmp1 = true;
            						}
HXDLIN( 653)						if (_hx_tmp1) {
HXLINE( 653)							colarb1->restitution = (int)1;
            						}
            						else {
HXLINE( 653)							colarb1->restitution = ((Float)(colarb1->s1->material->elasticity + colarb1->s2->material->elasticity) / (Float)(int)2);
            						}
            					}
HXDLIN( 653)					if ((colarb1->restitution < (int)0)) {
HXLINE( 653)						colarb1->restitution = (int)0;
            					}
HXDLIN( 653)					if ((colarb1->restitution > (int)1)) {
HXLINE( 653)						colarb1->restitution = (int)1;
            					}
            				}
HXDLIN( 653)				if (!(colarb1->userdef_dyn_fric)) {
HXLINE( 653)					colarb1->dyn_fric = ::Math_obj::sqrt((colarb1->s1->material->dynamicFriction * colarb1->s2->material->dynamicFriction));
            				}
HXDLIN( 653)				if (!(colarb1->userdef_stat_fric)) {
HXLINE( 653)					colarb1->stat_fric = ::Math_obj::sqrt((colarb1->s1->material->staticFriction * colarb1->s2->material->staticFriction));
            				}
HXDLIN( 653)				if (!(colarb1->userdef_rfric)) {
HXLINE( 653)					colarb1->rfric = ::Math_obj::sqrt((colarb1->s1->material->rollingFriction * colarb1->s2->material->rollingFriction));
            				}
            			}
            		}
HXDLIN( 653)		return colarb1->dyn_fric;
            	}


HX_DEFINE_DYNAMIC_FUNC1(CollisionArbiter_obj,set_dynamicFriction,return )

Float CollisionArbiter_obj::get_staticFriction(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_666_get_staticFriction)
            	HX_STACK_THIS(this)
HXLINE( 670)		HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 671)		if (colarb->invalidated) {
HXLINE( 671)			colarb->invalidated = false;
HXDLIN( 671)			{
HXLINE( 671)				if (!(colarb->userdef_restitution)) {
HXLINE( 671)					bool _hx_tmp;
HXDLIN( 671)					if (!((colarb->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 671)						_hx_tmp = (colarb->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 671)						_hx_tmp = true;
            					}
HXDLIN( 671)					if (_hx_tmp) {
HXLINE( 671)						colarb->restitution = (int)0;
            					}
            					else {
HXLINE( 671)						bool _hx_tmp1;
HXDLIN( 671)						if (!((colarb->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 671)							_hx_tmp1 = (colarb->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 671)							_hx_tmp1 = true;
            						}
HXDLIN( 671)						if (_hx_tmp1) {
HXLINE( 671)							colarb->restitution = (int)1;
            						}
            						else {
HXLINE( 671)							colarb->restitution = ((Float)(colarb->s1->material->elasticity + colarb->s2->material->elasticity) / (Float)(int)2);
            						}
            					}
HXDLIN( 671)					if ((colarb->restitution < (int)0)) {
HXLINE( 671)						colarb->restitution = (int)0;
            					}
HXDLIN( 671)					if ((colarb->restitution > (int)1)) {
HXLINE( 671)						colarb->restitution = (int)1;
            					}
            				}
HXDLIN( 671)				if (!(colarb->userdef_dyn_fric)) {
HXLINE( 671)					colarb->dyn_fric = ::Math_obj::sqrt((colarb->s1->material->dynamicFriction * colarb->s2->material->dynamicFriction));
            				}
HXDLIN( 671)				if (!(colarb->userdef_stat_fric)) {
HXLINE( 671)					colarb->stat_fric = ::Math_obj::sqrt((colarb->s1->material->staticFriction * colarb->s2->material->staticFriction));
            				}
HXDLIN( 671)				if (!(colarb->userdef_rfric)) {
HXLINE( 671)					colarb->rfric = ::Math_obj::sqrt((colarb->s1->material->rollingFriction * colarb->s2->material->rollingFriction));
            				}
            			}
            		}
HXLINE( 672)		return colarb->stat_fric;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_staticFriction,return )

Float CollisionArbiter_obj::set_staticFriction(Float staticFriction){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_674_set_staticFriction)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(staticFriction,"staticFriction")
HXLINE( 675)		{
HXLINE( 684)			HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 685)			colarb->stat_fric = staticFriction;
HXLINE( 686)			colarb->userdef_stat_fric = true;
            		}
HXLINE( 688)		HX_VARI_NAME(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb1,"colarb") = this->zpp_inner->colarb;
HXDLIN( 688)		if (colarb1->invalidated) {
HXLINE( 688)			colarb1->invalidated = false;
HXDLIN( 688)			{
HXLINE( 688)				if (!(colarb1->userdef_restitution)) {
HXLINE( 688)					bool _hx_tmp;
HXDLIN( 688)					if (!((colarb1->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 688)						_hx_tmp = (colarb1->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 688)						_hx_tmp = true;
            					}
HXDLIN( 688)					if (_hx_tmp) {
HXLINE( 688)						colarb1->restitution = (int)0;
            					}
            					else {
HXLINE( 688)						bool _hx_tmp1;
HXDLIN( 688)						if (!((colarb1->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 688)							_hx_tmp1 = (colarb1->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 688)							_hx_tmp1 = true;
            						}
HXDLIN( 688)						if (_hx_tmp1) {
HXLINE( 688)							colarb1->restitution = (int)1;
            						}
            						else {
HXLINE( 688)							colarb1->restitution = ((Float)(colarb1->s1->material->elasticity + colarb1->s2->material->elasticity) / (Float)(int)2);
            						}
            					}
HXDLIN( 688)					if ((colarb1->restitution < (int)0)) {
HXLINE( 688)						colarb1->restitution = (int)0;
            					}
HXDLIN( 688)					if ((colarb1->restitution > (int)1)) {
HXLINE( 688)						colarb1->restitution = (int)1;
            					}
            				}
HXDLIN( 688)				if (!(colarb1->userdef_dyn_fric)) {
HXLINE( 688)					colarb1->dyn_fric = ::Math_obj::sqrt((colarb1->s1->material->dynamicFriction * colarb1->s2->material->dynamicFriction));
            				}
HXDLIN( 688)				if (!(colarb1->userdef_stat_fric)) {
HXLINE( 688)					colarb1->stat_fric = ::Math_obj::sqrt((colarb1->s1->material->staticFriction * colarb1->s2->material->staticFriction));
            				}
HXDLIN( 688)				if (!(colarb1->userdef_rfric)) {
HXLINE( 688)					colarb1->rfric = ::Math_obj::sqrt((colarb1->s1->material->rollingFriction * colarb1->s2->material->rollingFriction));
            				}
            			}
            		}
HXDLIN( 688)		return colarb1->stat_fric;
            	}


HX_DEFINE_DYNAMIC_FUNC1(CollisionArbiter_obj,set_staticFriction,return )

Float CollisionArbiter_obj::get_rollingFriction(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_701_get_rollingFriction)
            	HX_STACK_THIS(this)
HXLINE( 705)		HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 706)		if (colarb->invalidated) {
HXLINE( 706)			colarb->invalidated = false;
HXDLIN( 706)			{
HXLINE( 706)				if (!(colarb->userdef_restitution)) {
HXLINE( 706)					bool _hx_tmp;
HXDLIN( 706)					if (!((colarb->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 706)						_hx_tmp = (colarb->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 706)						_hx_tmp = true;
            					}
HXDLIN( 706)					if (_hx_tmp) {
HXLINE( 706)						colarb->restitution = (int)0;
            					}
            					else {
HXLINE( 706)						bool _hx_tmp1;
HXDLIN( 706)						if (!((colarb->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 706)							_hx_tmp1 = (colarb->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 706)							_hx_tmp1 = true;
            						}
HXDLIN( 706)						if (_hx_tmp1) {
HXLINE( 706)							colarb->restitution = (int)1;
            						}
            						else {
HXLINE( 706)							colarb->restitution = ((Float)(colarb->s1->material->elasticity + colarb->s2->material->elasticity) / (Float)(int)2);
            						}
            					}
HXDLIN( 706)					if ((colarb->restitution < (int)0)) {
HXLINE( 706)						colarb->restitution = (int)0;
            					}
HXDLIN( 706)					if ((colarb->restitution > (int)1)) {
HXLINE( 706)						colarb->restitution = (int)1;
            					}
            				}
HXDLIN( 706)				if (!(colarb->userdef_dyn_fric)) {
HXLINE( 706)					colarb->dyn_fric = ::Math_obj::sqrt((colarb->s1->material->dynamicFriction * colarb->s2->material->dynamicFriction));
            				}
HXDLIN( 706)				if (!(colarb->userdef_stat_fric)) {
HXLINE( 706)					colarb->stat_fric = ::Math_obj::sqrt((colarb->s1->material->staticFriction * colarb->s2->material->staticFriction));
            				}
HXDLIN( 706)				if (!(colarb->userdef_rfric)) {
HXLINE( 706)					colarb->rfric = ::Math_obj::sqrt((colarb->s1->material->rollingFriction * colarb->s2->material->rollingFriction));
            				}
            			}
            		}
HXLINE( 707)		return colarb->rfric;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_rollingFriction,return )

Float CollisionArbiter_obj::set_rollingFriction(Float rollingFriction){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_709_set_rollingFriction)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(rollingFriction,"rollingFriction")
HXLINE( 710)		{
HXLINE( 719)			HX_VARI(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb) = this->zpp_inner->colarb;
HXLINE( 720)			colarb->rfric = rollingFriction;
HXLINE( 721)			colarb->userdef_rfric = true;
            		}
HXLINE( 723)		HX_VARI_NAME(  ::zpp_nape::dynamics::ZPP_ColArbiter,colarb1,"colarb") = this->zpp_inner->colarb;
HXDLIN( 723)		if (colarb1->invalidated) {
HXLINE( 723)			colarb1->invalidated = false;
HXDLIN( 723)			{
HXLINE( 723)				if (!(colarb1->userdef_restitution)) {
HXLINE( 723)					bool _hx_tmp;
HXDLIN( 723)					if (!((colarb1->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 723)						_hx_tmp = (colarb1->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 723)						_hx_tmp = true;
            					}
HXDLIN( 723)					if (_hx_tmp) {
HXLINE( 723)						colarb1->restitution = (int)0;
            					}
            					else {
HXLINE( 723)						bool _hx_tmp1;
HXDLIN( 723)						if (!((colarb1->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 723)							_hx_tmp1 = (colarb1->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 723)							_hx_tmp1 = true;
            						}
HXDLIN( 723)						if (_hx_tmp1) {
HXLINE( 723)							colarb1->restitution = (int)1;
            						}
            						else {
HXLINE( 723)							colarb1->restitution = ((Float)(colarb1->s1->material->elasticity + colarb1->s2->material->elasticity) / (Float)(int)2);
            						}
            					}
HXDLIN( 723)					if ((colarb1->restitution < (int)0)) {
HXLINE( 723)						colarb1->restitution = (int)0;
            					}
HXDLIN( 723)					if ((colarb1->restitution > (int)1)) {
HXLINE( 723)						colarb1->restitution = (int)1;
            					}
            				}
HXDLIN( 723)				if (!(colarb1->userdef_dyn_fric)) {
HXLINE( 723)					colarb1->dyn_fric = ::Math_obj::sqrt((colarb1->s1->material->dynamicFriction * colarb1->s2->material->dynamicFriction));
            				}
HXDLIN( 723)				if (!(colarb1->userdef_stat_fric)) {
HXLINE( 723)					colarb1->stat_fric = ::Math_obj::sqrt((colarb1->s1->material->staticFriction * colarb1->s2->material->staticFriction));
            				}
HXDLIN( 723)				if (!(colarb1->userdef_rfric)) {
HXLINE( 723)					colarb1->rfric = ::Math_obj::sqrt((colarb1->s1->material->rollingFriction * colarb1->s2->material->rollingFriction));
            				}
            			}
            		}
HXDLIN( 723)		return colarb1->rfric;
            	}


HX_DEFINE_DYNAMIC_FUNC1(CollisionArbiter_obj,set_rollingFriction,return )


hx::ObjectPtr< CollisionArbiter_obj > CollisionArbiter_obj::__new() {
	hx::ObjectPtr< CollisionArbiter_obj > __this = new CollisionArbiter_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< CollisionArbiter_obj > CollisionArbiter_obj::__alloc(hx::Ctx *_hx_ctx) {
	CollisionArbiter_obj *__this = (CollisionArbiter_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(CollisionArbiter_obj), true, "nape.dynamics.CollisionArbiter"));
	*(void **)__this = CollisionArbiter_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

CollisionArbiter_obj::CollisionArbiter_obj()
{
}

hx::Val CollisionArbiter_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"normal") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_normal()); }
		if (HX_FIELD_EQ(inName,"radius") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_radius()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"contacts") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_contacts()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"get_normal") ) { return hx::Val( get_normal_dyn()); }
		if (HX_FIELD_EQ(inName,"get_radius") ) { return hx::Val( get_radius_dyn()); }
		if (HX_FIELD_EQ(inName,"elasticity") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_elasticity()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"firstVertex") ) { return hx::Val( firstVertex_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_contacts") ) { return hx::Val( get_contacts_dyn()); }
		if (HX_FIELD_EQ(inName,"secondVertex") ) { return hx::Val( secondVertex_dyn()); }
		if (HX_FIELD_EQ(inName,"totalImpulse") ) { return hx::Val( totalImpulse_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"normalImpulse") ) { return hx::Val( normalImpulse_dyn()); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"referenceEdge1") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_referenceEdge1()); }
		if (HX_FIELD_EQ(inName,"referenceEdge2") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_referenceEdge2()); }
		if (HX_FIELD_EQ(inName,"tangentImpulse") ) { return hx::Val( tangentImpulse_dyn()); }
		if (HX_FIELD_EQ(inName,"rollingImpulse") ) { return hx::Val( rollingImpulse_dyn()); }
		if (HX_FIELD_EQ(inName,"get_elasticity") ) { return hx::Val( get_elasticity_dyn()); }
		if (HX_FIELD_EQ(inName,"set_elasticity") ) { return hx::Val( set_elasticity_dyn()); }
		if (HX_FIELD_EQ(inName,"staticFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_staticFriction()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"dynamicFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_dynamicFriction()); }
		if (HX_FIELD_EQ(inName,"rollingFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val(get_rollingFriction()); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"get_referenceEdge1") ) { return hx::Val( get_referenceEdge1_dyn()); }
		if (HX_FIELD_EQ(inName,"get_referenceEdge2") ) { return hx::Val( get_referenceEdge2_dyn()); }
		if (HX_FIELD_EQ(inName,"get_staticFriction") ) { return hx::Val( get_staticFriction_dyn()); }
		if (HX_FIELD_EQ(inName,"set_staticFriction") ) { return hx::Val( set_staticFriction_dyn()); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"get_dynamicFriction") ) { return hx::Val( get_dynamicFriction_dyn()); }
		if (HX_FIELD_EQ(inName,"set_dynamicFriction") ) { return hx::Val( set_dynamicFriction_dyn()); }
		if (HX_FIELD_EQ(inName,"get_rollingFriction") ) { return hx::Val( get_rollingFriction_dyn()); }
		if (HX_FIELD_EQ(inName,"set_rollingFriction") ) { return hx::Val( set_rollingFriction_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val CollisionArbiter_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"elasticity") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_elasticity(inValue) ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"staticFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_staticFriction(inValue) ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"dynamicFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_dynamicFriction(inValue) ); }
		if (HX_FIELD_EQ(inName,"rollingFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_rollingFriction(inValue) ); }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void CollisionArbiter_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("contacts","\xd3","\xd1","\x76","\x2c"));
	outFields->push(HX_HCSTRING("normal","\x27","\x72","\x69","\x30"));
	outFields->push(HX_HCSTRING("radius","\x52","\xd0","\xf6","\xb0"));
	outFields->push(HX_HCSTRING("referenceEdge1","\x89","\xb5","\x21","\x22"));
	outFields->push(HX_HCSTRING("referenceEdge2","\x8a","\xb5","\x21","\x22"));
	outFields->push(HX_HCSTRING("elasticity","\x79","\x23","\xb4","\x4d"));
	outFields->push(HX_HCSTRING("dynamicFriction","\x99","\xeb","\x8a","\xda"));
	outFields->push(HX_HCSTRING("staticFriction","\xc8","\x6f","\xc8","\x40"));
	outFields->push(HX_HCSTRING("rollingFriction","\x9f","\x6f","\x01","\xb7"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *CollisionArbiter_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *CollisionArbiter_obj_sStaticStorageInfo = 0;
#endif

static ::String CollisionArbiter_obj_sMemberFields[] = {
	HX_HCSTRING("get_contacts","\xdc","\x85","\x90","\xe1"),
	HX_HCSTRING("get_normal","\xf0","\xe1","\xf0","\x20"),
	HX_HCSTRING("get_radius","\x1b","\x40","\x7e","\xa1"),
	HX_HCSTRING("get_referenceEdge1","\x52","\x96","\xbb","\xbd"),
	HX_HCSTRING("get_referenceEdge2","\x53","\x96","\xbb","\xbd"),
	HX_HCSTRING("firstVertex","\xb4","\x0b","\xea","\x85"),
	HX_HCSTRING("secondVertex","\xf8","\x2d","\x23","\xdc"),
	HX_HCSTRING("normalImpulse","\x4e","\xa9","\x46","\x07"),
	HX_HCSTRING("tangentImpulse","\x70","\x2e","\x3e","\x65"),
	HX_HCSTRING("totalImpulse","\x51","\xe5","\xbb","\x16"),
	HX_HCSTRING("rollingImpulse","\xb0","\xb5","\xdd","\xca"),
	HX_HCSTRING("get_elasticity","\xc2","\xab","\xa9","\xc3"),
	HX_HCSTRING("set_elasticity","\x36","\x94","\xc9","\xe3"),
	HX_HCSTRING("get_dynamicFriction","\xb0","\xba","\x95","\x65"),
	HX_HCSTRING("set_dynamicFriction","\xbc","\xad","\x32","\xa2"),
	HX_HCSTRING("get_staticFriction","\x91","\x50","\x62","\xdc"),
	HX_HCSTRING("set_staticFriction","\x05","\x83","\x11","\xb9"),
	HX_HCSTRING("get_rollingFriction","\xb6","\x3e","\x0c","\x42"),
	HX_HCSTRING("set_rollingFriction","\xc2","\x31","\xa9","\x7e"),
	::String(null()) };

static void CollisionArbiter_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(CollisionArbiter_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void CollisionArbiter_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(CollisionArbiter_obj::__mClass,"__mClass");
};

#endif

hx::Class CollisionArbiter_obj::__mClass;

void CollisionArbiter_obj::__register()
{
	hx::Object *dummy = new CollisionArbiter_obj;
	CollisionArbiter_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("nape.dynamics.CollisionArbiter","\x4b","\xa8","\xe3","\x0b");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = CollisionArbiter_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(CollisionArbiter_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< CollisionArbiter_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = CollisionArbiter_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CollisionArbiter_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CollisionArbiter_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace nape
} // end namespace dynamics
