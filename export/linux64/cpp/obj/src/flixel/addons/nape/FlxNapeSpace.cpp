// Generated by Haxe 3.4.0
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_addons_nape_FlxNapeSpace
#include <flixel/addons/nape/FlxNapeSpace.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_PluginFrontEnd
#include <flixel/system/frontEnds/PluginFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SignalFrontEnd
#include <flixel/system/frontEnds/SignalFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxSignal
#include <flixel/util/IFlxSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxBaseSignal
#include <flixel/util/_FlxSignal/FlxBaseSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxSignal0
#include <flixel/util/_FlxSignal/FlxSignal0.h>
#endif
#ifndef INCLUDED_nape_dynamics_InteractionFilter
#include <nape/dynamics/InteractionFilter.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_nape_phys_Body
#include <nape/phys/Body.h>
#endif
#ifndef INCLUDED_nape_phys_BodyList
#include <nape/phys/BodyList.h>
#endif
#ifndef INCLUDED_nape_phys_BodyType
#include <nape/phys/BodyType.h>
#endif
#ifndef INCLUDED_nape_phys_Interactor
#include <nape/phys/Interactor.h>
#endif
#ifndef INCLUDED_nape_phys_Material
#include <nape/phys/Material.h>
#endif
#ifndef INCLUDED_nape_shape_Polygon
#include <nape/shape/Polygon.h>
#endif
#ifndef INCLUDED_nape_shape_Shape
#include <nape/shape/Shape.h>
#endif
#ifndef INCLUDED_nape_shape_ShapeList
#include <nape/shape/ShapeList.h>
#endif
#ifndef INCLUDED_nape_space_Broadphase
#include <nape/space/Broadphase.h>
#endif
#ifndef INCLUDED_nape_space_Space
#include <nape/space/Space.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Body
#include <zpp_nape/phys/ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Component
#include <zpp_nape/space/ZPP_Component.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Space
#include <zpp_nape/space/ZPP_Space.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_BodyList
#include <zpp_nape/util/ZPP_BodyList.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_Flags
#include <zpp_nape/util/ZPP_Flags.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_ShapeList
#include <zpp_nape/util/ZPP_ShapeList.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_ec5a246c46af3aa1_25_new,"flixel.addons.nape.FlxNapeSpace","new",0xf97484db,"flixel.addons.nape.FlxNapeSpace.new","flixel/addons/nape/FlxNapeSpace.hx",25,0x92717a34)
HX_DEFINE_STACK_FRAME(_hx_pos_ec5a246c46af3aa1_177_update,"flixel.addons.nape.FlxNapeSpace","update",0x4d9a906e,"flixel.addons.nape.FlxNapeSpace.update","flixel/addons/nape/FlxNapeSpace.hx",177,0x92717a34)
HX_DEFINE_STACK_FRAME(_hx_pos_ec5a246c46af3aa1_187_draw,"flixel.addons.nape.FlxNapeSpace","draw",0x45ed6329,"flixel.addons.nape.FlxNapeSpace.draw","flixel/addons/nape/FlxNapeSpace.hx",187,0x92717a34)
HX_DEFINE_STACK_FRAME(_hx_pos_ec5a246c46af3aa1_65_init,"flixel.addons.nape.FlxNapeSpace","init",0x49387235,"flixel.addons.nape.FlxNapeSpace.init","flixel/addons/nape/FlxNapeSpace.hx",65,0x92717a34)
HX_DEFINE_STACK_FRAME(_hx_pos_ec5a246c46af3aa1_96_createWalls,"flixel.addons.nape.FlxNapeSpace","createWalls",0x1f8c6b08,"flixel.addons.nape.FlxNapeSpace.createWalls","flixel/addons/nape/FlxNapeSpace.hx",96,0x92717a34)
HX_DEFINE_STACK_FRAME(_hx_pos_ec5a246c46af3aa1_153_set_drawDebug,"flixel.addons.nape.FlxNapeSpace","set_drawDebug",0x94fb79cd,"flixel.addons.nape.FlxNapeSpace.set_drawDebug","flixel/addons/nape/FlxNapeSpace.hx",153,0x92717a34)
HX_DEFINE_STACK_FRAME(_hx_pos_ec5a246c46af3aa1_158_onStateSwitch,"flixel.addons.nape.FlxNapeSpace","onStateSwitch",0x9253f041,"flixel.addons.nape.FlxNapeSpace.onStateSwitch","flixel/addons/nape/FlxNapeSpace.hx",158,0x92717a34)
HX_DEFINE_STACK_FRAME(_hx_pos_ec5a246c46af3aa1_34_boot,"flixel.addons.nape.FlxNapeSpace","boot",0x4498bb57,"flixel.addons.nape.FlxNapeSpace.boot","flixel/addons/nape/FlxNapeSpace.hx",34,0x92717a34)
HX_DEFINE_STACK_FRAME(_hx_pos_ec5a246c46af3aa1_40_boot,"flixel.addons.nape.FlxNapeSpace","boot",0x4498bb57,"flixel.addons.nape.FlxNapeSpace.boot","flixel/addons/nape/FlxNapeSpace.hx",40,0x92717a34)
namespace flixel{
namespace addons{
namespace nape{

void FlxNapeSpace_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_ec5a246c46af3aa1_25_new)
            	HX_STACK_THIS(this)
HXLINE(  25)		super::__construct();
            	}

Dynamic FlxNapeSpace_obj::__CreateEmpty() { return new FlxNapeSpace_obj; }

void *FlxNapeSpace_obj::_hx_vtable = 0;

Dynamic FlxNapeSpace_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxNapeSpace_obj > _hx_result = new FlxNapeSpace_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxNapeSpace_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x25a685e0) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x25a685e0;
	} else {
		return inClassId==(int)0x2cd610cb;
	}
}

void FlxNapeSpace_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_ec5a246c46af3aa1_177_update)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(elapsed,"elapsed")
HXLINE( 177)		bool _hx_tmp;
HXDLIN( 177)		if (hx::IsNotNull( ::flixel::addons::nape::FlxNapeSpace_obj::space )) {
HXLINE( 177)			_hx_tmp = (elapsed > (int)0);
            		}
            		else {
HXLINE( 177)			_hx_tmp = false;
            		}
HXDLIN( 177)		if (_hx_tmp) {
HXLINE( 179)			::flixel::addons::nape::FlxNapeSpace_obj::space->step(elapsed,::flixel::addons::nape::FlxNapeSpace_obj::velocityIterations,::flixel::addons::nape::FlxNapeSpace_obj::positionIterations);
            		}
            	}


void FlxNapeSpace_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_ec5a246c46af3aa1_187_draw)
            	HX_STACK_THIS(this)
            	}


 ::nape::space::Space FlxNapeSpace_obj::space;

int FlxNapeSpace_obj::velocityIterations;

int FlxNapeSpace_obj::positionIterations;

bool FlxNapeSpace_obj::drawDebug;

void FlxNapeSpace_obj::init(){
            	HX_GC_STACKFRAME(&_hx_pos_ec5a246c46af3aa1_65_init)
HXLINE(  66)		::flixel::FlxG_obj::plugins->add_flixel_addons_nape_FlxNapeSpace( ::flixel::addons::nape::FlxNapeSpace_obj::__alloc( HX_CTX ));
HXLINE(  68)		if (hx::IsNull( ::flixel::addons::nape::FlxNapeSpace_obj::space )) {
HXLINE(  70)			::flixel::addons::nape::FlxNapeSpace_obj::space =  ::nape::space::Space_obj::__alloc( HX_CTX , ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null()),null());
            		}
HXLINE(  73)		::flixel::FlxG_obj::signals->stateSwitched->add(::flixel::addons::nape::FlxNapeSpace_obj::onStateSwitch_dyn());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(FlxNapeSpace_obj,init,(void))

 ::nape::phys::Body FlxNapeSpace_obj::createWalls(hx::Null< Float >  __o_minX,hx::Null< Float >  __o_minY,hx::Null< Float >  __o_maxX,hx::Null< Float >  __o_maxY,hx::Null< Float >  __o_thickness, ::nape::phys::Material material){
Float minX = __o_minX.Default(0);
Float minY = __o_minY.Default(0);
Float maxX = __o_maxX.Default(0);
Float maxY = __o_maxY.Default(0);
Float thickness = __o_thickness.Default(10);
            	HX_GC_STACKFRAME(&_hx_pos_ec5a246c46af3aa1_96_createWalls)
            	HX_STACK_ARG(minX,"minX")
            	HX_STACK_ARG(minY,"minY")
            	HX_STACK_ARG(maxX,"maxX")
            	HX_STACK_ARG(maxY,"maxY")
            	HX_STACK_ARG(thickness,"thickness")
            	HX_STACK_ARG(material,"material")
HXLINE(  97)		if ((maxX == (int)0)) {
HXLINE(  99)			maxX = ::flixel::FlxG_obj::width;
            		}
HXLINE( 102)		if ((maxY == (int)0)) {
HXLINE( 104)			maxY = ::flixel::FlxG_obj::height;
            		}
HXLINE( 107)		if (hx::IsNull( material )) {
HXLINE( 109)			material =  ::nape::phys::Material_obj::__alloc( HX_CTX ,((Float)0.4),((Float)0.2),((Float)0.38),((Float)0.7),null());
            		}
HXLINE( 112)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::BodyType_STATIC )) {
HXLINE( 112)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN( 112)			::zpp_nape::util::ZPP_Flags_obj::BodyType_STATIC =  ::nape::phys::BodyType_obj::__alloc( HX_CTX );
HXDLIN( 112)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN( 112)		HX_VARI(  ::nape::phys::Body,walls) =  ::nape::phys::Body_obj::__alloc( HX_CTX ,::zpp_nape::util::ZPP_Flags_obj::BodyType_STATIC,null());
HXLINE( 115)		{
HXLINE( 115)			HX_VARI(  ::nape::shape::ShapeList,_this) = walls->zpp_inner->wrap_shapes;
HXDLIN( 115)			HX_VARI(  ::nape::shape::Shape,obj) =  ::nape::shape::Polygon_obj::__alloc( HX_CTX ,::nape::shape::Polygon_obj::rect((minX - thickness),minY,thickness,(maxY + ::Math_obj::abs(minY)),null()),null(),null());
HXDLIN( 115)			if (_this->zpp_inner->reverse_flag) {
HXLINE( 115)				_this->push(obj);
            			}
            			else {
HXLINE( 115)				_this->unshift(obj);
            			}
            		}
HXLINE( 117)		{
HXLINE( 117)			HX_VARI_NAME(  ::nape::shape::ShapeList,_this1,"_this") = walls->zpp_inner->wrap_shapes;
HXDLIN( 117)			HX_VARI_NAME(  ::nape::shape::Shape,obj1,"obj") =  ::nape::shape::Polygon_obj::__alloc( HX_CTX ,::nape::shape::Polygon_obj::rect(maxX,minY,thickness,(maxY + ::Math_obj::abs(minY)),null()),null(),null());
HXDLIN( 117)			if (_this1->zpp_inner->reverse_flag) {
HXLINE( 117)				_this1->push(obj1);
            			}
            			else {
HXLINE( 117)				_this1->unshift(obj1);
            			}
            		}
HXLINE( 119)		{
HXLINE( 119)			HX_VARI_NAME(  ::nape::shape::ShapeList,_this2,"_this") = walls->zpp_inner->wrap_shapes;
HXDLIN( 119)			HX_VARI_NAME(  ::nape::shape::Shape,obj2,"obj") =  ::nape::shape::Polygon_obj::__alloc( HX_CTX ,::nape::shape::Polygon_obj::rect(minX,(minY - thickness),(maxX + ::Math_obj::abs(minX)),thickness,null()),null(),null());
HXDLIN( 119)			if (_this2->zpp_inner->reverse_flag) {
HXLINE( 119)				_this2->push(obj2);
            			}
            			else {
HXLINE( 119)				_this2->unshift(obj2);
            			}
            		}
HXLINE( 121)		{
HXLINE( 121)			HX_VARI_NAME(  ::nape::shape::ShapeList,_this3,"_this") = walls->zpp_inner->wrap_shapes;
HXDLIN( 121)			HX_VARI_NAME(  ::nape::shape::Shape,obj3,"obj") =  ::nape::shape::Polygon_obj::__alloc( HX_CTX ,::nape::shape::Polygon_obj::rect(minX,maxY,(maxX + ::Math_obj::abs(minX)),thickness,null()),null(),null());
HXDLIN( 121)			if (_this3->zpp_inner->reverse_flag) {
HXLINE( 121)				_this3->push(obj3);
            			}
            			else {
HXLINE( 121)				_this3->unshift(obj3);
            			}
            		}
HXLINE( 123)		{
HXLINE( 123)			HX_VARI(  ::nape::space::Space,space) = ::flixel::addons::nape::FlxNapeSpace_obj::space;
HXDLIN( 123)			{
HXLINE( 123)				walls->zpp_inner->immutable_midstep(HX_("Body::space",84,f7,bc,26));
HXDLIN( 123)				 ::nape::space::Space _hx_tmp;
HXDLIN( 123)				if (hx::IsNull( walls->zpp_inner->space )) {
HXLINE( 123)					_hx_tmp = null();
            				}
            				else {
HXLINE( 123)					_hx_tmp = walls->zpp_inner->space->outer;
            				}
HXDLIN( 123)				if (hx::IsNotEq( _hx_tmp,space )) {
HXLINE( 123)					 ::nape::space::Space _hx_tmp1;
HXDLIN( 123)					if (hx::IsNull( walls->zpp_inner->space )) {
HXLINE( 123)						_hx_tmp1 = null();
            					}
            					else {
HXLINE( 123)						_hx_tmp1 = walls->zpp_inner->space->outer;
            					}
HXDLIN( 123)					if (hx::IsNotNull( _hx_tmp1 )) {
HXLINE( 123)						walls->zpp_inner->component->woken = false;
            					}
HXDLIN( 123)					 ::nape::space::Space _hx_tmp2;
HXDLIN( 123)					if (hx::IsNull( walls->zpp_inner->space )) {
HXLINE( 123)						_hx_tmp2 = null();
            					}
            					else {
HXLINE( 123)						_hx_tmp2 = walls->zpp_inner->space->outer;
            					}
HXDLIN( 123)					if (hx::IsNotNull( _hx_tmp2 )) {
HXLINE( 123)						 ::nape::space::Space _this4;
HXDLIN( 123)						if (hx::IsNull( walls->zpp_inner->space )) {
HXLINE( 123)							_this4 = null();
            						}
            						else {
HXLINE( 123)							_this4 = walls->zpp_inner->space->outer;
            						}
HXDLIN( 123)						_this4->zpp_inner->wrap_bodies->remove(walls);
            					}
HXDLIN( 123)					if (hx::IsNotNull( space )) {
HXLINE( 123)						HX_VARI_NAME(  ::nape::phys::BodyList,_this5,"_this") = space->zpp_inner->wrap_bodies;
HXDLIN( 123)						if (_this5->zpp_inner->reverse_flag) {
HXLINE( 123)							_this5->push(walls);
            						}
            						else {
HXLINE( 123)							_this5->unshift(walls);
            						}
            					}
            				}
            			}
            		}
HXLINE( 124)		walls->setShapeMaterials(material);
HXLINE( 126)		return walls;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(FlxNapeSpace_obj,createWalls,return )

bool FlxNapeSpace_obj::set_drawDebug(bool drawDebug){
            	HX_STACKFRAME(&_hx_pos_ec5a246c46af3aa1_153_set_drawDebug)
            	HX_STACK_ARG(drawDebug,"drawDebug")
HXLINE( 153)		return (::flixel::addons::nape::FlxNapeSpace_obj::drawDebug = drawDebug);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxNapeSpace_obj,set_drawDebug,return )

void FlxNapeSpace_obj::onStateSwitch(){
            	HX_STACKFRAME(&_hx_pos_ec5a246c46af3aa1_158_onStateSwitch)
HXLINE( 158)		if (hx::IsNotNull( ::flixel::addons::nape::FlxNapeSpace_obj::space )) {
HXLINE( 160)			::flixel::addons::nape::FlxNapeSpace_obj::space->clear();
HXLINE( 161)			::flixel::addons::nape::FlxNapeSpace_obj::space = null();
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(FlxNapeSpace_obj,onStateSwitch,(void))


hx::ObjectPtr< FlxNapeSpace_obj > FlxNapeSpace_obj::__new() {
	hx::ObjectPtr< FlxNapeSpace_obj > __this = new FlxNapeSpace_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< FlxNapeSpace_obj > FlxNapeSpace_obj::__alloc(hx::Ctx *_hx_ctx) {
	FlxNapeSpace_obj *__this = (FlxNapeSpace_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(FlxNapeSpace_obj), true, "flixel.addons.nape.FlxNapeSpace"));
	*(void **)__this = FlxNapeSpace_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

FlxNapeSpace_obj::FlxNapeSpace_obj()
{
}

hx::Val FlxNapeSpace_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn()); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxNapeSpace_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"init") ) { outValue = init_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"space") ) { outValue = space; return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"drawDebug") ) { outValue = drawDebug; return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"createWalls") ) { outValue = createWalls_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"set_drawDebug") ) { outValue = set_drawDebug_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"onStateSwitch") ) { outValue = onStateSwitch_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"velocityIterations") ) { outValue = velocityIterations; return true; }
		if (HX_FIELD_EQ(inName,"positionIterations") ) { outValue = positionIterations; return true; }
	}
	return false;
}

bool FlxNapeSpace_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"space") ) { space=ioValue.Cast<  ::nape::space::Space >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"drawDebug") ) { if (inCallProp == hx::paccAlways)  ioValue = set_drawDebug(ioValue); else drawDebug=ioValue.Cast< bool >(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"velocityIterations") ) { velocityIterations=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"positionIterations") ) { positionIterations=ioValue.Cast< int >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *FlxNapeSpace_obj_sMemberStorageInfo = 0;
static hx::StaticInfo FlxNapeSpace_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::nape::space::Space*/ ,(void *) &FlxNapeSpace_obj::space,HX_HCSTRING("space","\xc6","\x8c","\x66","\x81")},
	{hx::fsInt,(void *) &FlxNapeSpace_obj::velocityIterations,HX_HCSTRING("velocityIterations","\xb3","\x9f","\x71","\xb7")},
	{hx::fsInt,(void *) &FlxNapeSpace_obj::positionIterations,HX_HCSTRING("positionIterations","\x3f","\x65","\x42","\x76")},
	{hx::fsBool,(void *) &FlxNapeSpace_obj::drawDebug,HX_HCSTRING("drawDebug","\xaf","\x87","\x2a","\x9f")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxNapeSpace_obj_sMemberFields[] = {
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	HX_HCSTRING("draw","\x04","\x2c","\x70","\x42"),
	::String(null()) };

static void FlxNapeSpace_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxNapeSpace_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(FlxNapeSpace_obj::space,"space");
	HX_MARK_MEMBER_NAME(FlxNapeSpace_obj::velocityIterations,"velocityIterations");
	HX_MARK_MEMBER_NAME(FlxNapeSpace_obj::positionIterations,"positionIterations");
	HX_MARK_MEMBER_NAME(FlxNapeSpace_obj::drawDebug,"drawDebug");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxNapeSpace_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxNapeSpace_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(FlxNapeSpace_obj::space,"space");
	HX_VISIT_MEMBER_NAME(FlxNapeSpace_obj::velocityIterations,"velocityIterations");
	HX_VISIT_MEMBER_NAME(FlxNapeSpace_obj::positionIterations,"positionIterations");
	HX_VISIT_MEMBER_NAME(FlxNapeSpace_obj::drawDebug,"drawDebug");
};

#endif

hx::Class FlxNapeSpace_obj::__mClass;

static ::String FlxNapeSpace_obj_sStaticFields[] = {
	HX_HCSTRING("space","\xc6","\x8c","\x66","\x81"),
	HX_HCSTRING("velocityIterations","\xb3","\x9f","\x71","\xb7"),
	HX_HCSTRING("positionIterations","\x3f","\x65","\x42","\x76"),
	HX_HCSTRING("drawDebug","\xaf","\x87","\x2a","\x9f"),
	HX_HCSTRING("init","\x10","\x3b","\xbb","\x45"),
	HX_HCSTRING("createWalls","\x8d","\x43","\x9a","\xee"),
	HX_HCSTRING("set_drawDebug","\x92","\x3d","\x94","\xa5"),
	HX_HCSTRING("onStateSwitch","\x06","\xb4","\xec","\xa2"),
	::String(null())
};

void FlxNapeSpace_obj::__register()
{
	hx::Object *dummy = new FlxNapeSpace_obj;
	FlxNapeSpace_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.addons.nape.FlxNapeSpace","\x69","\x7b","\x4c","\x06");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxNapeSpace_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxNapeSpace_obj::__SetStatic;
	__mClass->mMarkFunc = FlxNapeSpace_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxNapeSpace_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(FlxNapeSpace_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< FlxNapeSpace_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxNapeSpace_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxNapeSpace_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxNapeSpace_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxNapeSpace_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_ec5a246c46af3aa1_34_boot)
HXLINE(  34)		velocityIterations = (int)10;
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec5a246c46af3aa1_40_boot)
HXLINE(  40)		positionIterations = (int)10;
            	}
}

} // end namespace flixel
} // end namespace addons
} // end namespace nape
