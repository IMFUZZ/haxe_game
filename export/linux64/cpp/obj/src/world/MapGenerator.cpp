// Generated by Haxe 3.4.0
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_addons_nape_FlxNapeTilemap
#include <flixel/addons/nape/FlxNapeTilemap.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_BitmapFrontEnd
#include <flixel/system/frontEnds/BitmapFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxBaseTilemap
#include <flixel/tile/FlxBaseTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemap
#include <flixel/tile/FlxTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemapAutoTiling
#include <flixel/tile/FlxTilemapAutoTiling.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_Output
#include <haxe/io/Output.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_utils_ByteArray
#include <openfl/_legacy/utils/ByteArray.h>
#endif
#ifndef INCLUDED_openfl__legacy_utils_IDataInput
#include <openfl/_legacy/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl__legacy_utils_IDataOutput
#include <openfl/_legacy/utils/IDataOutput.h>
#endif
#ifndef INCLUDED_openfl__legacy_utils_IMemoryRange
#include <openfl/_legacy/utils/IMemoryRange.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif
#ifndef INCLUDED_sys_io_FileOutput
#include <sys/io/FileOutput.h>
#endif
#ifndef INCLUDED_world_MapGenerator
#include <world/MapGenerator.h>
#endif
#ifndef INCLUDED_world_WorldMap
#include <world/WorldMap.h>
#endif
#ifndef INCLUDED_world_WorldTilemap
#include <world/WorldTilemap.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec2
#include <zpp_nape/geom/ZPP_Vec2.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_cffb5a9995b086ff_14_new,"world.MapGenerator","new",0x60c85845,"world.MapGenerator.new","world/MapGenerator.hx",14,0x0c803fea)
HX_DEFINE_STACK_FRAME(_hx_pos_cffb5a9995b086ff_29_generate,"world.MapGenerator","generate",0x121e1930,"world.MapGenerator.generate","world/MapGenerator.hx",29,0x0c803fea)
HX_DEFINE_STACK_FRAME(_hx_pos_cffb5a9995b086ff_55_getWorldMap,"world.MapGenerator","getWorldMap",0xbf45a305,"world.MapGenerator.getWorldMap","world/MapGenerator.hx",55,0x0c803fea)
HX_DEFINE_STACK_FRAME(_hx_pos_cffb5a9995b086ff_58_generateTileMap,"world.MapGenerator","generateTileMap",0x47043cbe,"world.MapGenerator.generateTileMap","world/MapGenerator.hx",58,0x0c803fea)
HX_DEFINE_STACK_FRAME(_hx_pos_cffb5a9995b086ff_65_saveWorldMap,"world.MapGenerator","saveWorldMap",0xeff38b42,"world.MapGenerator.saveWorldMap","world/MapGenerator.hx",65,0x0c803fea)
HX_DEFINE_STACK_FRAME(_hx_pos_cffb5a9995b086ff_82_generateWorldMapBitmap,"world.MapGenerator","generateWorldMapBitmap",0x6bacbc49,"world.MapGenerator.generateWorldMapBitmap","world/MapGenerator.hx",82,0x0c803fea)
HX_DEFINE_STACK_FRAME(_hx_pos_cffb5a9995b086ff_107_clear,"world.MapGenerator","clear",0x14ed7cb2,"world.MapGenerator.clear","world/MapGenerator.hx",107,0x0c803fea)
HX_DEFINE_STACK_FRAME(_hx_pos_cffb5a9995b086ff_113_divide,"world.MapGenerator","divide",0xf249e4b4,"world.MapGenerator.divide","world/MapGenerator.hx",113,0x0c803fea)
HX_DEFINE_STACK_FRAME(_hx_pos_cffb5a9995b086ff_142_transformToValueRange,"world.MapGenerator","transformToValueRange",0x06da7e98,"world.MapGenerator.transformToValueRange","world/MapGenerator.hx",142,0x0c803fea)
HX_DEFINE_STACK_FRAME(_hx_pos_cffb5a9995b086ff_169_getViewable,"world.MapGenerator","getViewable",0xad6b6e1a,"world.MapGenerator.getViewable","world/MapGenerator.hx",169,0x0c803fea)
namespace world{

void MapGenerator_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_cffb5a9995b086ff_14_new)
            	HX_STACK_THIS(this)
HXLINE(  17)		this->_displacement = ((Float)1.4);
HXLINE(  25)		this->spawnPoint =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,(int)-1,(int)-1);
HXLINE(  26)		this->table = ::Array_obj< ::Dynamic>::__new();
            	}

Dynamic MapGenerator_obj::__CreateEmpty() { return new MapGenerator_obj; }

void *MapGenerator_obj::_hx_vtable = 0;

Dynamic MapGenerator_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< MapGenerator_obj > _hx_result = new MapGenerator_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool MapGenerator_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7fe57fc1;
}

 ::world::WorldTilemap MapGenerator_obj::generate(int a_size,::String tileFilePath){
            	HX_STACKFRAME(&_hx_pos_cffb5a9995b086ff_29_generate)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(a_size,"a_size")
            	HX_STACK_ARG(tileFilePath,"tileFilePath")
HXLINE(  31)		this->_size = ::Std_obj::_hx_int((::Math_obj::pow((int)2,a_size) + (int)1));
HXLINE(  32)		this->clear();
HXLINE(  33)		{
HXLINE(  33)			HX_VARI( int,_g1) = (int)0;
HXDLIN(  33)			HX_VARI( int,_g) = this->_size;
HXDLIN(  33)			while((_g1 < _g)){
HXLINE(  33)				_g1 = (_g1 + (int)1);
HXDLIN(  33)				HX_VARI( int,x) = (_g1 - (int)1);
HXLINE(  34)				::Array< ::Dynamic> _hx_tmp = this->table;
HXDLIN(  34)				_hx_tmp->push(::Array_obj< int >::__new());
HXLINE(  35)				{
HXLINE(  35)					HX_VARI( int,_g3) = (int)0;
HXDLIN(  35)					HX_VARI( int,_g2) = this->_size;
HXDLIN(  35)					while((_g3 < _g2)){
HXLINE(  35)						_g3 = (_g3 + (int)1);
HXLINE(  36)						this->table->__get(x).StaticCast< ::Array< int > >()->push((int)-1);
            					}
            				}
            			}
            		}
HXLINE(  39)		this->table->__get((int)0).StaticCast< ::Array< int > >()[(int)0] = ::Std_obj::_hx_int(::Math_obj::random());
HXLINE(  40)		this->table->__get((int)0).StaticCast< ::Array< int > >()[(this->_size - (int)1)] = ::Std_obj::_hx_int(::Math_obj::random());
HXLINE(  41)		this->table->__get((this->_size - (int)1)).StaticCast< ::Array< int > >()[(int)0] = ::Std_obj::_hx_int(::Math_obj::random());
HXLINE(  42)		this->table->__get((this->_size - (int)1)).StaticCast< ::Array< int > >()[(this->_size - (int)1)] = ::Std_obj::_hx_int(::Math_obj::random());
HXLINE(  43)		this->table = this->divide(this->table,(int)0,(int)0,(this->_size - (int)1),(this->_size - (int)1),this->_displacement);
HXLINE(  44)		this->table = this->transformToValueRange((int)8);
HXLINE(  46)		this->generateTileMap(tileFilePath);
HXLINE(  47)		this->generateWorldMapBitmap();
HXLINE(  48)		this->saveWorldMap(HX_("txt",70,6e,58,00),this->table);
HXLINE(  49)		this->saveWorldMap(HX_("png",a9,5c,55,00),this->table);
HXLINE(  51)		return this->worldMapTileMap;
            	}


HX_DEFINE_DYNAMIC_FUNC2(MapGenerator_obj,generate,return )

 ::world::WorldMap MapGenerator_obj::getWorldMap(){
            	HX_STACKFRAME(&_hx_pos_cffb5a9995b086ff_55_getWorldMap)
            	HX_STACK_THIS(this)
HXLINE(  55)		return this->worldMap;
            	}


HX_DEFINE_DYNAMIC_FUNC0(MapGenerator_obj,getWorldMap,return )

void MapGenerator_obj::generateTileMap(::String tileFilePath){
            	HX_GC_STACKFRAME(&_hx_pos_cffb5a9995b086ff_58_generateTileMap)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(tileFilePath,"tileFilePath")
HXLINE(  59)		this->worldMapTileMap =  ::world::WorldTilemap_obj::__alloc( HX_CTX );
HXLINE(  60)		Dynamic( this->worldMapTileMap->loadMapFrom2DArray(this->table,tileFilePath,(int)32,(int)32,null(),null(),null(),null())).StaticCast<  ::flixel::tile::FlxTilemap >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(MapGenerator_obj,generateTileMap,(void))

void MapGenerator_obj::saveWorldMap(::String format,::Array< ::Dynamic> table){
            	HX_STACKFRAME(&_hx_pos_cffb5a9995b086ff_65_saveWorldMap)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(format,"format")
            	HX_STACK_ARG(table,"table")
HXLINE(  66)		HX_VARI(  ::sys::io::FileOutput,file) = null();
HXLINE(  67)		::String _hx_switch_0 = format;
            		if (  (_hx_switch_0==HX_("png",a9,5c,55,00)) ){
HXLINE(  69)			HX_VARI(  ::openfl::_legacy::utils::ByteArray,b) = this->worldMap->bitmap->encode(HX_("png",a9,5c,55,00),(int)1,null());
HXLINE(  70)			file = ::sys::io::File_obj::write(HX_("assets/images/worldMap.png",d0,31,01,ec),true);
HXLINE(  71)			file->writeString(b->toString());
HXLINE(  72)			file->close();
HXLINE(  68)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("txt",70,6e,58,00)) ){
HXLINE(  73)			goto _hx_goto_6;
            		}
            		/* default */{
HXLINE(  75)			::sys::FileSystem_obj::createDirectory(HX_("save",3d,8b,4d,4c));
HXLINE(  76)			file = ::sys::io::File_obj::write(HX_("save/world.txt",c2,41,78,96),false);
HXLINE(  77)			file->writeString(::StringTools_obj::replace(table->toString(),HX_("],",2f,51,00,00),HX_("],\n",fb,b7,46,00)));
HXLINE(  78)			file->close();
            		}
            		_hx_goto_6:;
            	}


HX_DEFINE_DYNAMIC_FUNC2(MapGenerator_obj,saveWorldMap,(void))

void MapGenerator_obj::generateWorldMapBitmap(){
            	HX_GC_STACKFRAME(&_hx_pos_cffb5a9995b086ff_82_generateWorldMapBitmap)
            	HX_STACK_THIS(this)
HXLINE(  83)		HX_VAR( int,maxSize);
HXDLIN(  83)		int maxSize1 = ::flixel::FlxG_obj::bitmap->get_maxTextureSize();
HXDLIN(  83)		if ((maxSize1 <= this->_size)) {
HXLINE(  83)			maxSize = ::flixel::FlxG_obj::bitmap->get_maxTextureSize();
            		}
            		else {
HXLINE(  83)			maxSize = this->_size;
            		}
HXLINE(  84)		HX_VARI(  ::openfl::_legacy::display::BitmapData,worldMapBitmap) =  ::openfl::_legacy::display::BitmapData_obj::__alloc( HX_CTX ,maxSize,maxSize,false,(int)65280,null());
HXLINE(  85)		{
HXLINE(  85)			HX_VARI( int,_g1) = (int)0;
HXDLIN(  85)			HX_VARI( int,_g) = maxSize;
HXDLIN(  85)			while((_g1 < _g)){
HXLINE(  85)				_g1 = (_g1 + (int)1);
HXDLIN(  85)				HX_VARI( int,x) = (_g1 - (int)1);
HXLINE(  86)				{
HXLINE(  86)					HX_VARI( int,_g3) = (int)0;
HXDLIN(  86)					HX_VARI( int,_g2) = maxSize;
HXDLIN(  86)					while((_g3 < _g2)){
HXLINE(  86)						_g3 = (_g3 + (int)1);
HXDLIN(  86)						HX_VARI( int,y) = (_g3 - (int)1);
HXLINE(  87)						HX_VARI( int,color) = (int)0;
HXLINE(  88)						switch((int)(this->table->__get(y).StaticCast< ::Array< int > >()->__get(x))){
            							case (int)1: {
HXLINE(  89)								color = (int)414691;
            							}
            							break;
            							case (int)2: {
HXLINE(  90)								color = (int)5153261;
            							}
            							break;
            							case (int)3: {
HXLINE(  91)								color = (int)14326840;
            							}
            							break;
            							case (int)4: {
HXLINE(  92)								color = (int)5024554;
            							}
            							break;
            							case (int)5: {
HXLINE(  93)								color = (int)2978068;
            							}
            							break;
            							case (int)6: {
HXLINE(  94)								color = (int)7632244;
            							}
            							break;
            							case (int)7: {
HXLINE(  95)								color = (int)13684944;
            							}
            							break;
            							case (int)8: {
HXLINE(  96)								color = (int)16250871;
            							}
            							break;
            							default:{
HXLINE(  97)								color = (int)0;
            							}
            						}
HXLINE(  99)						worldMapBitmap->setPixel(x,y,color);
            					}
            				}
            			}
            		}
HXLINE( 102)		this->worldMap =  ::world::WorldMap_obj::__alloc( HX_CTX ,(int)0,(int)0,worldMapBitmap);
            	}


HX_DEFINE_DYNAMIC_FUNC0(MapGenerator_obj,generateWorldMapBitmap,(void))

void MapGenerator_obj::clear(){
            	HX_STACKFRAME(&_hx_pos_cffb5a9995b086ff_107_clear)
            	HX_STACK_THIS(this)
HXLINE( 107)		this->table->removeRange((int)0,this->table->length);
            	}


HX_DEFINE_DYNAMIC_FUNC0(MapGenerator_obj,clear,(void))

::Array< ::Dynamic> MapGenerator_obj::divide(::Array< ::Dynamic> a_table,int x1,int y1,int x2,int y2,Float a_displacement){
            	HX_STACKFRAME(&_hx_pos_cffb5a9995b086ff_113_divide)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(a_table,"a_table")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(y1,"y1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(y2,"y2")
            	HX_STACK_ARG(a_displacement,"a_displacement")
HXLINE( 114)		HX_VARI( int,diffX) = (x2 - x1);
HXLINE( 116)		HX_VARI( int,cx) = ::Std_obj::_hx_int((x1 + ((Float)diffX / (Float)(int)2)));
HXLINE( 117)		HX_VARI( int,cy) = ::Std_obj::_hx_int((y1 + ((Float)(y2 - y1) / (Float)(int)2)));
HXLINE( 118)		HX_VARI( Float,d2) = ((Float)a_displacement / (Float)(int)2);
HXLINE( 119)		if ((diffX > (int)1)) {
HXLINE( 120)			a_table->__get(cy).StaticCast< ::Array< int > >()[cx] = ::Std_obj::_hx_int(((((Float)(((a_table->__get(y1).StaticCast< ::Array< int > >()->__get(x1) + a_table->__get(y2).StaticCast< ::Array< int > >()->__get(x2)) + a_table->__get(y1).StaticCast< ::Array< int > >()->__get(x2)) + a_table->__get(y2).StaticCast< ::Array< int > >()->__get(x1)) / (Float)(int)4) + ((::Math_obj::random() * (int)10) * a_displacement)) - d2));
HXLINE( 121)			if ((a_table->__get(y1).StaticCast< ::Array< int > >()->__get(cx) == (int)-1)) {
HXLINE( 122)				a_table->__get(y1).StaticCast< ::Array< int > >()[cx] = ::Std_obj::_hx_int(((((Float)(a_table->__get(y1).StaticCast< ::Array< int > >()->__get(x1) + a_table->__get(y1).StaticCast< ::Array< int > >()->__get(x2)) / (Float)(int)2) + ((::Math_obj::random() * (int)10) * a_displacement)) - d2));
            			}
HXLINE( 124)			if ((a_table->__get(y2).StaticCast< ::Array< int > >()->__get(cx) == (int)-1)) {
HXLINE( 125)				a_table->__get(y2).StaticCast< ::Array< int > >()[cx] = ::Std_obj::_hx_int(((((Float)(a_table->__get(y2).StaticCast< ::Array< int > >()->__get(x1) + a_table->__get(y2).StaticCast< ::Array< int > >()->__get(x2)) / (Float)(int)2) + ((::Math_obj::random() * (int)10) * a_displacement)) - d2));
            			}
HXLINE( 127)			if ((a_table->__get(cy).StaticCast< ::Array< int > >()->__get(x1) == (int)-1)) {
HXLINE( 128)				a_table->__get(cy).StaticCast< ::Array< int > >()[x1] = ::Std_obj::_hx_int(((((Float)(a_table->__get(y1).StaticCast< ::Array< int > >()->__get(x1) + a_table->__get(y2).StaticCast< ::Array< int > >()->__get(x1)) / (Float)(int)2) + ((::Math_obj::random() * (int)10) * a_displacement)) - d2));
            			}
HXLINE( 130)			if ((a_table->__get(cy).StaticCast< ::Array< int > >()->__get(x2) == (int)-1)) {
HXLINE( 131)				a_table->__get(cy).StaticCast< ::Array< int > >()[x2] = ::Std_obj::_hx_int(((((Float)(a_table->__get(y1).StaticCast< ::Array< int > >()->__get(x2) + a_table->__get(y2).StaticCast< ::Array< int > >()->__get(x2)) / (Float)(int)2) + ((::Math_obj::random() * (int)10) * a_displacement)) - d2));
            			}
HXLINE( 133)			HX_VARI( Float,new_displacement) = ((Float)a_displacement / (Float)this->_displacement);
HXLINE( 134)			a_table = this->divide(a_table,x1,y1,cx,cy,new_displacement);
HXLINE( 135)			a_table = this->divide(a_table,cx,y1,x2,cy,new_displacement);
HXLINE( 136)			a_table = this->divide(a_table,x1,cy,cx,y2,new_displacement);
HXLINE( 137)			a_table = this->divide(a_table,cx,cy,x2,y2,new_displacement);
            		}
HXLINE( 139)		return a_table;
            	}


HX_DEFINE_DYNAMIC_FUNC6(MapGenerator_obj,divide,return )

::Array< ::Dynamic> MapGenerator_obj::transformToValueRange(int a_valueRange){
            	HX_STACKFRAME(&_hx_pos_cffb5a9995b086ff_142_transformToValueRange)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(a_valueRange,"a_valueRange")
HXLINE( 143)		HX_VARI( int,s) = (int)-1;
HXLINE( 144)		HX_VARI( int,b) = (int)-1;
HXLINE( 145)		{
HXLINE( 145)			HX_VARI( int,_g1) = (int)0;
HXDLIN( 145)			HX_VARI( int,_g) = this->table->length;
HXDLIN( 145)			while((_g1 < _g)){
HXLINE( 145)				_g1 = (_g1 + (int)1);
HXDLIN( 145)				HX_VARI( int,y) = (_g1 - (int)1);
HXLINE( 146)				{
HXLINE( 146)					HX_VARI( int,_g3) = (int)0;
HXDLIN( 146)					HX_VARI( int,_g2) = this->table->__get(y).StaticCast< ::Array< int > >()->length;
HXDLIN( 146)					while((_g3 < _g2)){
HXLINE( 146)						_g3 = (_g3 + (int)1);
HXDLIN( 146)						HX_VARI( int,x) = (_g3 - (int)1);
HXLINE( 147)						bool _hx_tmp;
HXDLIN( 147)						if ((s != (int)-1)) {
HXLINE( 147)							_hx_tmp = (this->table->__get(y).StaticCast< ::Array< int > >()->__get(x) < s);
            						}
            						else {
HXLINE( 147)							_hx_tmp = true;
            						}
HXDLIN( 147)						if (_hx_tmp) {
HXLINE( 148)							s = this->table->__get(y).StaticCast< ::Array< int > >()->__get(x);
            						}
HXLINE( 150)						bool _hx_tmp1;
HXDLIN( 150)						if ((b != (int)-1)) {
HXLINE( 150)							_hx_tmp1 = (this->table->__get(y).StaticCast< ::Array< int > >()->__get(x) > b);
            						}
            						else {
HXLINE( 150)							_hx_tmp1 = true;
            						}
HXDLIN( 150)						if (_hx_tmp1) {
HXLINE( 151)							b = this->table->__get(y).StaticCast< ::Array< int > >()->__get(x);
            						}
            					}
            				}
            			}
            		}
HXLINE( 155)		HX_VARI( int,diff) = (b - s);
HXLINE( 156)		{
HXLINE( 156)			HX_VARI_NAME( int,_g11,"_g1") = (int)0;
HXDLIN( 156)			HX_VARI_NAME( int,_g4,"_g") = this->table->length;
HXDLIN( 156)			while((_g11 < _g4)){
HXLINE( 156)				_g11 = (_g11 + (int)1);
HXDLIN( 156)				HX_VARI_NAME( int,y1,"y") = (_g11 - (int)1);
HXLINE( 157)				{
HXLINE( 157)					HX_VARI_NAME( int,_g31,"_g3") = (int)0;
HXDLIN( 157)					HX_VARI_NAME( int,_g21,"_g2") = this->table->__get(y1).StaticCast< ::Array< int > >()->length;
HXDLIN( 157)					while((_g31 < _g21)){
HXLINE( 157)						_g31 = (_g31 + (int)1);
HXDLIN( 157)						HX_VARI_NAME( int,x1,"x") = (_g31 - (int)1);
HXLINE( 158)						this->table->__get(y1).StaticCast< ::Array< int > >()[x1] = ::Std_obj::_hx_int((((Float)(this->table->__get(y1).StaticCast< ::Array< int > >()->__get(x1) - s) / (Float)diff) * a_valueRange));
HXLINE( 159)						if ((this->table->__get(y1).StaticCast< ::Array< int > >()->__get(x1) == (int)0)) {
HXLINE( 159)							this->table->__get(y1).StaticCast< ::Array< int > >()[x1] = (int)1;
            						}
HXLINE( 160)						bool _hx_tmp2;
HXDLIN( 160)						bool _hx_tmp3;
HXDLIN( 160)						bool _hx_tmp4;
HXDLIN( 160)						bool _hx_tmp5;
HXDLIN( 160)						HX_VARI(  ::nape::geom::Vec2,_this) = this->spawnPoint;
HXDLIN( 160)						{
HXLINE( 160)							HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec2,_this1,"_this") = _this->zpp_inner;
HXDLIN( 160)							if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 160)								_this1->_validate();
            							}
            						}
HXDLIN( 160)						if ((_this->zpp_inner->x == (int)-1)) {
HXLINE( 160)							HX_VARI_NAME(  ::nape::geom::Vec2,_this2,"_this") = this->spawnPoint;
HXDLIN( 160)							{
HXLINE( 160)								HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec2,_this3,"_this") = _this2->zpp_inner;
HXDLIN( 160)								if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 160)									_this3->_validate();
            								}
            							}
HXDLIN( 160)							_hx_tmp5 = (_this2->zpp_inner->y == (int)-1);
            						}
            						else {
HXLINE( 160)							_hx_tmp5 = false;
            						}
HXDLIN( 160)						if (_hx_tmp5) {
HXLINE( 160)							_hx_tmp4 = (x1 > ((Float)this->_size / (Float)(int)3));
            						}
            						else {
HXLINE( 160)							_hx_tmp4 = false;
            						}
HXDLIN( 160)						if (_hx_tmp4) {
HXLINE( 160)							_hx_tmp3 = (y1 > ((Float)this->_size / (Float)(int)3));
            						}
            						else {
HXLINE( 160)							_hx_tmp3 = false;
            						}
HXDLIN( 160)						if (_hx_tmp3) {
HXLINE( 160)							_hx_tmp2 = (this->table->__get(y1).StaticCast< ::Array< int > >()->__get(x1) == (int)4);
            						}
            						else {
HXLINE( 160)							_hx_tmp2 = false;
            						}
HXDLIN( 160)						if (_hx_tmp2) {
HXLINE( 161)							{
HXLINE( 161)								HX_VARI_NAME(  ::nape::geom::Vec2,_this4,"_this") = this->spawnPoint;
HXDLIN( 161)								HX_VARI_NAME( Float,x2,"x") = (x1 * (int)32);
HXDLIN( 161)								{
HXLINE( 161)									{
HXLINE( 161)										HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec2,_this5,"_this") = _this4->zpp_inner;
HXDLIN( 161)										if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 161)											_this5->_validate();
            										}
            									}
HXDLIN( 161)									if ((_this4->zpp_inner->x != x2)) {
HXLINE( 161)										_this4->zpp_inner->x = x2;
HXDLIN( 161)										{
HXLINE( 161)											HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec2,_this6,"_this") = _this4->zpp_inner;
HXDLIN( 161)											if (hx::IsNotNull( _this6->_invalidate )) {
HXLINE( 161)												_this6->_invalidate(_this6);
            											}
            										}
            									}
            								}
HXDLIN( 161)								{
HXLINE( 161)									HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec2,_this7,"_this") = _this4->zpp_inner;
HXDLIN( 161)									if (hx::IsNotNull( _this7->_validate )) {
HXLINE( 161)										_this7->_validate();
            									}
            								}
            							}
HXLINE( 162)							{
HXLINE( 162)								HX_VARI_NAME(  ::nape::geom::Vec2,_this8,"_this") = this->spawnPoint;
HXDLIN( 162)								HX_VARI_NAME( Float,y2,"y") = (y1 * (int)32);
HXDLIN( 162)								{
HXLINE( 162)									{
HXLINE( 162)										HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec2,_this9,"_this") = _this8->zpp_inner;
HXDLIN( 162)										if (hx::IsNotNull( _this9->_validate )) {
HXLINE( 162)											_this9->_validate();
            										}
            									}
HXDLIN( 162)									if ((_this8->zpp_inner->y != y2)) {
HXLINE( 162)										_this8->zpp_inner->y = y2;
HXDLIN( 162)										{
HXLINE( 162)											HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec2,_this10,"_this") = _this8->zpp_inner;
HXDLIN( 162)											if (hx::IsNotNull( _this10->_invalidate )) {
HXLINE( 162)												_this10->_invalidate(_this10);
            											}
            										}
            									}
            								}
HXDLIN( 162)								{
HXLINE( 162)									HX_VARI_NAME(  ::zpp_nape::geom::ZPP_Vec2,_this11,"_this") = _this8->zpp_inner;
HXDLIN( 162)									if (hx::IsNotNull( _this11->_validate )) {
HXLINE( 162)										_this11->_validate();
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 166)		return this->table;
            	}


HX_DEFINE_DYNAMIC_FUNC1(MapGenerator_obj,transformToValueRange,return )

::Array< ::Dynamic> MapGenerator_obj::getViewable(int tileSize){
            	HX_STACKFRAME(&_hx_pos_cffb5a9995b086ff_169_getViewable)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(tileSize,"tileSize")
HXLINE( 170)		HX_VARI( int,indexAStart) = ::Std_obj::_hx_int((((Float)::flixel::FlxG_obj::camera->x / (Float)(int)32) * ::flixel::FlxG_obj::camera->zoom));
HXLINE( 171)		HX_VARI( int,indexAEnd) = ::Std_obj::_hx_int((((Float)(::flixel::FlxG_obj::camera->x + ::flixel::FlxG_obj::camera->width) / (Float)(int)32) * ::flixel::FlxG_obj::camera->zoom));
HXLINE( 172)		HX_VARI( int,indexBStart) = ::Std_obj::_hx_int((((Float)::flixel::FlxG_obj::camera->y / (Float)(int)32) * ::flixel::FlxG_obj::camera->zoom));
HXLINE( 173)		HX_VARI( int,indexBEnd) = ::Std_obj::_hx_int((((Float)(::flixel::FlxG_obj::camera->y + ::flixel::FlxG_obj::camera->height) / (Float)(int)32) * ::flixel::FlxG_obj::camera->zoom));
HXLINE( 174)		HX_VARI( ::Array< ::Dynamic>,tempTable) = ::Array_obj< ::Dynamic>::__new();
HXLINE( 175)		{
HXLINE( 175)			HX_VARI( int,_g1) = indexBStart;
HXDLIN( 175)			while((_g1 < indexBEnd)){
HXLINE( 175)				_g1 = (_g1 + (int)1);
HXDLIN( 175)				HX_VARI( int,y) = (_g1 - (int)1);
HXLINE( 176)				tempTable->push(::Array_obj< int >::__new());
HXLINE( 177)				{
HXLINE( 177)					HX_VARI( int,_g3) = indexAStart;
HXDLIN( 177)					while((_g3 < indexAEnd)){
HXLINE( 177)						_g3 = (_g3 + (int)1);
HXLINE( 178)						tempTable->__get(y).StaticCast< ::Array< int > >()->push(this->table->__get(y).StaticCast< ::Array< int > >()->__get((_g3 - (int)1)));
            					}
            				}
            			}
            		}
HXLINE( 181)		return tempTable;
            	}


HX_DEFINE_DYNAMIC_FUNC1(MapGenerator_obj,getViewable,return )


hx::ObjectPtr< MapGenerator_obj > MapGenerator_obj::__new() {
	hx::ObjectPtr< MapGenerator_obj > __this = new MapGenerator_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< MapGenerator_obj > MapGenerator_obj::__alloc(hx::Ctx *_hx_ctx) {
	MapGenerator_obj *__this = (MapGenerator_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(MapGenerator_obj), true, "world.MapGenerator"));
	*(void **)__this = MapGenerator_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

MapGenerator_obj::MapGenerator_obj()
{
}

void MapGenerator_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(MapGenerator);
	HX_MARK_MEMBER_NAME(_size,"_size");
	HX_MARK_MEMBER_NAME(_displacement,"_displacement");
	HX_MARK_MEMBER_NAME(_valueRange,"_valueRange");
	HX_MARK_MEMBER_NAME(table,"table");
	HX_MARK_MEMBER_NAME(spawnPoint,"spawnPoint");
	HX_MARK_MEMBER_NAME(worldMapTileMap,"worldMapTileMap");
	HX_MARK_MEMBER_NAME(worldMap,"worldMap");
	HX_MARK_END_CLASS();
}

void MapGenerator_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_size,"_size");
	HX_VISIT_MEMBER_NAME(_displacement,"_displacement");
	HX_VISIT_MEMBER_NAME(_valueRange,"_valueRange");
	HX_VISIT_MEMBER_NAME(table,"table");
	HX_VISIT_MEMBER_NAME(spawnPoint,"spawnPoint");
	HX_VISIT_MEMBER_NAME(worldMapTileMap,"worldMapTileMap");
	HX_VISIT_MEMBER_NAME(worldMap,"worldMap");
}

hx::Val MapGenerator_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_size") ) { return hx::Val( _size); }
		if (HX_FIELD_EQ(inName,"table") ) { return hx::Val( table); }
		if (HX_FIELD_EQ(inName,"clear") ) { return hx::Val( clear_dyn()); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"divide") ) { return hx::Val( divide_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"worldMap") ) { return hx::Val( worldMap); }
		if (HX_FIELD_EQ(inName,"generate") ) { return hx::Val( generate_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"spawnPoint") ) { return hx::Val( spawnPoint); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_valueRange") ) { return hx::Val( _valueRange); }
		if (HX_FIELD_EQ(inName,"getWorldMap") ) { return hx::Val( getWorldMap_dyn()); }
		if (HX_FIELD_EQ(inName,"getViewable") ) { return hx::Val( getViewable_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"saveWorldMap") ) { return hx::Val( saveWorldMap_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_displacement") ) { return hx::Val( _displacement); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"worldMapTileMap") ) { return hx::Val( worldMapTileMap); }
		if (HX_FIELD_EQ(inName,"generateTileMap") ) { return hx::Val( generateTileMap_dyn()); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"transformToValueRange") ) { return hx::Val( transformToValueRange_dyn()); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"generateWorldMapBitmap") ) { return hx::Val( generateWorldMapBitmap_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val MapGenerator_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_size") ) { _size=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"table") ) { table=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"worldMap") ) { worldMap=inValue.Cast<  ::world::WorldMap >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"spawnPoint") ) { spawnPoint=inValue.Cast<  ::nape::geom::Vec2 >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_valueRange") ) { _valueRange=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_displacement") ) { _displacement=inValue.Cast< Float >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"worldMapTileMap") ) { worldMapTileMap=inValue.Cast<  ::world::WorldTilemap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void MapGenerator_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("_size","\xa0","\xbc","\x64","\xff"));
	outFields->push(HX_HCSTRING("_displacement","\xb6","\xe5","\x91","\xff"));
	outFields->push(HX_HCSTRING("_valueRange","\xab","\xc9","\x45","\x5e"));
	outFields->push(HX_HCSTRING("table","\x0e","\xb8","\xe3","\x0a"));
	outFields->push(HX_HCSTRING("spawnPoint","\x15","\x10","\xa8","\x00"));
	outFields->push(HX_HCSTRING("worldMapTileMap","\xc4","\x05","\x33","\xaa"));
	outFields->push(HX_HCSTRING("worldMap","\x6a","\x6b","\x8b","\xa4"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo MapGenerator_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(MapGenerator_obj,_size),HX_HCSTRING("_size","\xa0","\xbc","\x64","\xff")},
	{hx::fsFloat,(int)offsetof(MapGenerator_obj,_displacement),HX_HCSTRING("_displacement","\xb6","\xe5","\x91","\xff")},
	{hx::fsInt,(int)offsetof(MapGenerator_obj,_valueRange),HX_HCSTRING("_valueRange","\xab","\xc9","\x45","\x5e")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(MapGenerator_obj,table),HX_HCSTRING("table","\x0e","\xb8","\xe3","\x0a")},
	{hx::fsObject /*::nape::geom::Vec2*/ ,(int)offsetof(MapGenerator_obj,spawnPoint),HX_HCSTRING("spawnPoint","\x15","\x10","\xa8","\x00")},
	{hx::fsObject /*::world::WorldTilemap*/ ,(int)offsetof(MapGenerator_obj,worldMapTileMap),HX_HCSTRING("worldMapTileMap","\xc4","\x05","\x33","\xaa")},
	{hx::fsObject /*::world::WorldMap*/ ,(int)offsetof(MapGenerator_obj,worldMap),HX_HCSTRING("worldMap","\x6a","\x6b","\x8b","\xa4")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *MapGenerator_obj_sStaticStorageInfo = 0;
#endif

static ::String MapGenerator_obj_sMemberFields[] = {
	HX_HCSTRING("_size","\xa0","\xbc","\x64","\xff"),
	HX_HCSTRING("_displacement","\xb6","\xe5","\x91","\xff"),
	HX_HCSTRING("_valueRange","\xab","\xc9","\x45","\x5e"),
	HX_HCSTRING("table","\x0e","\xb8","\xe3","\x0a"),
	HX_HCSTRING("spawnPoint","\x15","\x10","\xa8","\x00"),
	HX_HCSTRING("worldMapTileMap","\xc4","\x05","\x33","\xaa"),
	HX_HCSTRING("worldMap","\x6a","\x6b","\x8b","\xa4"),
	HX_HCSTRING("generate","\x35","\x5f","\xa2","\xd9"),
	HX_HCSTRING("getWorldMap","\x20","\x2e","\x7f","\xca"),
	HX_HCSTRING("generateTileMap","\x59","\xf1","\x30","\x21"),
	HX_HCSTRING("saveWorldMap","\xc7","\xb7","\x13","\xb7"),
	HX_HCSTRING("generateWorldMapBitmap","\x0e","\xa1","\xc9","\x88"),
	HX_HCSTRING("clear","\x8d","\x71","\x5b","\x48"),
	HX_HCSTRING("divide","\x79","\x2f","\x12","\xbf"),
	HX_HCSTRING("transformToValueRange","\x73","\x19","\x05","\x0f"),
	HX_HCSTRING("getViewable","\x35","\xf9","\xa4","\xb8"),
	::String(null()) };

static void MapGenerator_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(MapGenerator_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void MapGenerator_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(MapGenerator_obj::__mClass,"__mClass");
};

#endif

hx::Class MapGenerator_obj::__mClass;

void MapGenerator_obj::__register()
{
	hx::Object *dummy = new MapGenerator_obj;
	MapGenerator_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("world.MapGenerator","\xd3","\xd1","\xc3","\x67");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = MapGenerator_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(MapGenerator_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< MapGenerator_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = MapGenerator_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = MapGenerator_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = MapGenerator_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace world
